(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{441:function(s,a,n){"use strict";n.r(a);var t=n(2),e=Object(t.a)({},(function(){var s=this,a=s.$createElement,n=s._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("details",{staticClass:"custom-block details"},[n("summary",[s._v("Java有没有goto语句")]),n("p",[s._v("goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。根据 James Gosling（Java 之父）编写的《The Java Programming Language》一书的附录中给出了一个 Java 关键字列表，其中有 goto 和 const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉 C 语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字。")])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("&和&&的区别")]),n("p",[s._v('&运算符有两种用法：(1)按位与；(2)逻辑与。\n&&运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。\n&&之所以称为短路运算是因为，如果&&左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&&而不是&，例如在验证用户登录时判定用户名不是 null 而且不是空字符串，应当写为 username != null &&!username.equals("")，二者的顺序不能交换，更不能用&运算符，因为第一个条件如果不成立，根本不能进行字符串的 equals 比较，否则会产生 NullPointerException 异常。注意：逻辑或运算符（|） 和短路或运算符（||）的差别也是如此。')])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("在Java中，如何跳出当前的多重嵌套循环")]),n("p",[s._v("在最外层循环前加一个标记如  A，然后用  break A;可以跳出多重循环。（Java  中支持带标签的 break 和 continue语句，作用有点类似于 C 和 C++中的 goto 语句，但是就像要避免使用 goto 一样，应该避免使用带标签的 break 和 continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用）。")])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("两个对象值相同 (x.equals(y) == true) ，但却可有不同的 hashCode")]),n("p",[s._v("不对，如果两个对象 x 和 y 满足 x.equals(y) == true，它们的哈希码（hashCode）应当相同。")]),s._v(" "),n("p",[s._v('Java 对于 eqauls 方法和 hashCode 方法是这样规定的：(1)如果两个对象相同（equals 方法返回 true），那么它们的 hashCode 值一定要相同；(2)如果两个对象的 hashCode 相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在 Set 集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。\n关于 equals 和 hashCode 方法，很多 Java 程序员都知道，但很多人也就是仅仅知道而已，在 Joshua Bloch 的大作《Effective Java》（很多软件公司，《Effective Java》、《Java 编程思想》以及《重构：改善既有代码质量》是 Java 程序员必看书籍，如果你还没看过，那就赶紧去买一本吧）中是这样介绍 equals 方法的。\n首先 equals 方法必须满足自反性（x.equals(x)必须返回 true）、对称性（x.equals(y)返回 true 时，y.equals(x) 也必须返回 true）、传递性（x.equals(y)和 y.equals(z)都返回 true 时，x.equals(z)也必须返回 true）和一致性（当x 和 y 引用的对象信息没有被修改时，多次调用 x.equals(y)应该得到同样的返回值），而且对于任何非 null 值的引用 x，x.equals(null)必须返回 false。实现高质量的 equals 方法的诀窍包括：1. 使用==操作符检查"参数是否为这个对象的引用"；2. 使用 instanceof 操作符检查"参数是否为正确的类型"；3. 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；4. 编写完 equals 方法后，问自己它是否满足对称性、传递性、一致性；5. 重写 equals 时总是要重写 hashCode；6. 不要将 equals 方法参数中的 Object 对象替换为其他的类型，在重写时不要忘掉\n@Override 注解。')])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("是否可以继承 String")]),n("p",[s._v("String 类是 final 类，不可以被继承。\n继承 String 本身就是一个错误的行为，对 String 类型最好的重用方式是关联关系（Has-A）和依赖关系（Use- A）而不是继承关系（Is-A）。")])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并 可返回变化后的结果，那么这里到底是值传递还是引用传递?")]),n("p",[s._v("是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。C++ 和 C#中可以通过传引用或传输出参数来改变传入的参数的值。说明：Java 中没有传引用实在是非常的不方便，这一点在 Java 8 中仍然没有得到改进，正是如此在 Java 编写的代码中才会出现大量的 Wrapper 类（将需要通过方法调用修改的引用置于一个 Wrapper 类中，再将 Wrapper 对象传入方法），这样的做法只会让代码变得臃肿，尤其是让从 C 和 C++转型为 Java 程序员的开发者无法容忍。")])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("重载（overload）和重写（override）的区别？重载的方法能否根据返回类型 进行区分？")]),n("p",[s._v("方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("方法重载的规则：\n1.方法名一致，参数列表中参数的顺序，类型，个数不同。\n2.重载与方法的返回值无关，存在于父类和子类，同类中。\n3.可以抛出不同的异常，可以有不同修饰符。\n\n方法重写的规则：\n1.参数列表必须完全与被重写方法的一致，返回类型必须完全与被重写方法的返回类型一致。\n2.构造方法不能被重写，声明为 final 的方法不能被重写，声明为 static 的方法不能被重写，但是能够被再次声明。\n3.访问权限不能比父类中被重写的方法的访问权限更低。\n4.重写的方法能够抛出任何非强制异常（UncheckedException，也叫非运行时异常），无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br")])])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("为什么函数不能根据返回类型来区分重载？")]),n("p",[s._v("因为调用时不能指定类型信息，编译器不知道你要调用哪个函数。")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("float max(int a, int b); 2．int max(int a, int b);\n当调用 max(1, 2);时无法确定调用的是哪个，单从这一点上来说，仅返回值类型不同的重载是不应该允许的。再比如对下面这两个方法来说，虽然它们有同样的名字和自变量，但其实是很容易区分的：\n\n1.void f() {}\n2.int f() {}\n\n若编译器可根据上下文（语境）明确判断出含义，比如在 int x=f()中，那么这样做完全没有问题。然而，\n\n我们也可能调用一个方法，同时忽略返回值；我们通常把这称为“为它的副作用去调用一个方法”，因为我 们关心的不是返回值，而是方法调用的其他效果。所以假如我们像下面这样调用方法： f(); Java 怎样判断 f()的具体调 用方式呢？而且别人如何识别并理解代码呢？由于存在这一类的问题，所以不能。\n\n函数的返回值只是作为函数运行之后的一个“状态”，他是保持方法的调用者与被调用者进行通信的关键。并不能作为某个方法的“标识”。\n\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br")])])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("char 型变量中能不能存储一个中文汉字，为什么？")]),n("p",[s._v("char 类型可以存储一个中文汉字，因为 Java 中使用的编码是 Unicode（不选择任何特定的编码，直接 使用字符在字符集中的编号，这是统一的唯一方法），一个 char 类型占 2 个字节（16 比特），所以放一个中文是没问题的。\n补充：使用 Unicode 意味着字符在 JVM 内部和外部有不同的表现形式，在 JVM 内部都是 Unicode，当这个字符被从 JVM 内部转移到外部时（例如存入文件系统中），需要进行编码转换。所以 Java 中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如 InputStreamReader 和 OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务；对于 C 程序员来说，要完成这样的编码转换恐怕要依赖于 union（联合体/共用体）共享内存的特征来实现了。")])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("抽象类(abstract class)和接口(interface)有什么异同？")]),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("不同：\n抽象类：\n1.抽象类中可以定义构造器\n2.可以有抽象方法和具体方法 3.接口中的成员全都是 public 的 4.抽象类中可以定义成员变量\n5.有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法\n6.抽象类中可以包含静态方法\n7.一个类只能继承一个抽象类接口：\n1.接口中不能定义构造器\n2.方法全部都是抽象方法\n2.抽象类中的成员可以是 private、默认、protected、public        4.接口中定义的成员变量实际上都是常量5.接口中不能有静态方法\n6.一个类可以实现多个接口\n相同：\n1.不能够实例化\n2.可以将抽象类和接口类型作为引用类型\n3.一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br")])])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("抽象的(abstract)方法是否可同时是静态的(static), 是否可同时是本地方法(native)，是否可同时被 synchronized")]),n("p",[s._v("都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由 本地代码\n（如 C 代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized 和方法的实现细节有关， 抽象方法不涉及实现细节，因此也是相互矛盾的。")])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("阐述静态变量和实例变量的区别？")]),n("p",[s._v("静态变量: 是被 static 修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；\n实例变量: 必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。")])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("==和 equals 的区别？")]),n("p",[s._v("equals 和== 最大的区别是一个是方法一个是运算符。\n==：如果比较的对象是基本数据类型，则比较的是数值是否相等；如果比较的是引用数据类型，则比较的是对象的地址值是否相等。\nequals()：用来比较方法两个对象的内容是否相等。\n注意：equals 方法不能用于基本数据类型的变量，如果没有对 equals 方法进行重写，则比较的是引用类型的变量所指向的对象的地址。")])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("break 和 continue 的区别？")]),n("p",[s._v("break 和 continue 都是用来控制循环的语句。\nbreak 用于完全结束一个循环，跳出循环体执行循环后面的语句。continue 用于跳过本次循环，执行下次循环。")])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v('String s = "Hello";s = s + " world!";这两行代码执行后，原始的 String 对象 中的内容到底变了没有？')]),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('没有。\n因为 String 被设计成不可变(immutable)类，所以它的所有对象都是不可变对象。\n在这段代码中，s 原先指向一个 String 对象，内容是 "Hello"，然后我们对 s 进行了“+”操作，那么 s 所指向的那个对象是否发生了改变呢？ \n答案是没有。\n这时，s 不指向原来那个对象了，而指向了另一个 String 对象，内容为"Hello world!"，原来那个对象还存在于内存之中，只是 s 这个引用变量不再指向它了。\n通过上面的说明，我们很容易导出另一个结论，\n如果经常对字符串进行各种各样的修改，或者说，不可预见的修改，那么使用 String 来代表字符串的话会引起很大的内存开销。\n因为 String 对象建立之后不能再改变，所以对于每一个不同的字符串，都需要一个 String 对象来表示。\n这时，应该考虑使用 StringBuffer 类，它允许修改，而不是每个不同的字符串都要生成一个新的对象。\n并且，这两种类的对象转换十分容易。同时，我们还可以知道，如果要使用内容相同的字符串，不必每次都 new 一个 String。\n例如我们要在构造器中对一个名叫 s 的 String 引用变量进行初始化， 把它设置为初始值，应当这样做：\npublic class Demo {\nprivate String s; \n\t...\n\ts = "Initial Value"; \n\t...\n}\n而非\ns = new String("Initial Value");\t\n后者每次都会调用构造器，生成新对象，性能低下且内存开销大，并且没有意义，\n因为 String 对象不可改变，所以对于内容相同的字符串，只要一个 String 对象来表示就可以了。\n也就说，多次调用上面的构造器创建多个对象，他们的 String 类型属性 s 都指向同一个对象。\n上面的结论还基于这样一个事实：对于字符串常量，如果内容相同，Java 认为它们代表同一个 String 对象。\n而用关键字 new 调用构造器，总是会创建一个新的对象，无论内容是否相同。 \n至于为什么要把 String 类设计成不可变类，是它的用途决定的。\n其实不只 String，很多 Java 标准类库中的类都是不可变的。\n在开发一个系统的时候，我们有时候也需要设计不可变类，来传递一组相关的值，这也是面向对象思想的体现。\n不可变类有一些优点，比如因为它的对象是只读的，所以多线程并发访问也不会有任何问题。\n当然也有一些缺点，比如每个不同的状态都要一个对象来代表，可能会造成性能上的问题。\n所以 Java 标准类库还提供了一个可变版本，即 StringBuffer。\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br")])])])])}),[],!1,null,null,null);a.default=e.exports}}]);