(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{443:function(s,n,t){"use strict";t.r(n);var a=t(2),e=Object(a.a)({},(function(){var s=this,n=s.$createElement,t=s._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("Boxx"),s._v(" "),t("h2",{attrs:{id:"面向对象的三大特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面向对象的三大特性"}},[s._v("#")]),s._v(" 面向对象的三大特性")]),s._v(" "),t("details",{staticClass:"custom-block details"},[t("summary",[s._v("继承")]),t("ol",[t("li",[t("strong",[s._v("继承是从已有类得到继承信息创建新类的过程。")])]),s._v(" "),t("li",[t("strong",[s._v("提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。")])]),s._v(" "),t("li",[t("strong",[s._v("继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。")])])])]),t("details",{staticClass:"custom-block details"},[t("summary",[s._v("封装")]),t("ol",[t("li",[t("strong",[s._v("通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。")])]),s._v(" "),t("li",[t("strong",[s._v("面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；")])]),s._v(" "),t("li",[t("strong",[s._v("我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口。")])])])]),t("details",{staticClass:"custom-block details"},[t("summary",[s._v("多态")]),t("ol",[t("li",[t("strong",[s._v("多态性是指允许不同子类型的对象对同一消息作出不同的响应。")])]),s._v(" "),t("li",[t("strong",[s._v("简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。")])]),s._v(" "),t("li",[t("strong",[s._v("多态性分为编译时的多态性和运行时的多态性。")])])]),s._v(" "),t("ul",[t("li",[s._v("多态性：编译时多态和运行时多态\n"),t("em",[s._v("编译时多态")]),s._v("：(前绑定)方法重载"),t("br"),s._v(" "),t("em",[s._v("运行时多态")]),s._v("：（后绑定）方法重写")]),s._v(" "),t("li",[s._v("解释\n如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：\n当 A 系统访问 B 系统提供的服务时，B 系统有多种提供服务的方式， 但一切对 A 系统来说都是透明的。\n方法重载（overload）实现的是编译时的多态性（也称为前绑定），\n而方法重写（override）实现的是运行时的多态性（也称为后绑定）。\n运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：")])]),s._v(" "),t("ol",[t("li",[s._v("方法重写（子类继承父类并重写父类中已有的或抽象的方法）；")]),s._v(" "),t("li",[s._v("对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。")])])]),t("details",{staticClass:"custom-block details"},[t("summary",[s._v("抽象")]),t("ol",[t("li",[t("strong",[s._v("抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。")])]),s._v(" "),t("li",[t("strong",[s._v("抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。")])])])]),t("ul",[t("li",[s._v("注意：默认情况下面向对象有 3 大特性，封装、继承、多态，如果面试官问让说出 4 大特性，那么我们就把抽象加上去。")])]),s._v(" "),t("h2",{attrs:{id:"访问权限修饰符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#访问权限修饰符"}},[s._v("#")]),s._v(" 访问权限修饰符")]),s._v(" "),t("table",[t("thead",[t("tr",[t("th",[s._v("修饰符")]),s._v(" "),t("th",[s._v("当前类")]),s._v(" "),t("th",[s._v("同包")]),s._v(" "),t("th",[s._v("子类")]),s._v(" "),t("th",[s._v("其他包")])])]),s._v(" "),t("tbody",[t("tr",[t("td",[s._v("public")]),s._v(" "),t("td",[s._v("可")]),s._v(" "),t("td",[s._v("可")]),s._v(" "),t("td",[s._v("可")]),s._v(" "),t("td",[s._v("可")])]),s._v(" "),t("tr",[t("td",[s._v("protected")]),s._v(" "),t("td",[s._v("可")]),s._v(" "),t("td",[s._v("可")]),s._v(" "),t("td",[s._v("可")]),s._v(" "),t("td",[s._v("不可")])]),s._v(" "),t("tr",[t("td",[s._v("default")]),s._v(" "),t("td",[s._v("可")]),s._v(" "),t("td",[s._v("可")]),s._v(" "),t("td",[s._v("不可")]),s._v(" "),t("td",[s._v("不可")])]),s._v(" "),t("tr",[t("td",[s._v("private")]),s._v(" "),t("td",[s._v("可")]),s._v(" "),t("td",[s._v("不可")]),s._v(" "),t("td",[s._v("不可")]),s._v(" "),t("td",[s._v("不可")])])])]),s._v(" "),t("h2",{attrs:{id:"clone对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#clone对象"}},[s._v("#")]),s._v(" Clone对象")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("clone的起因：\n在实际编程过程中，我们常常要遇到这种情况：\n有一个对象 A，在某一时刻 A 中已经包含了一些有效值，此时可能会需要一个和 A 完全相同新对象 B，\n并且此后对 B 任何改动都不会影响到 A 中的值，也就是说，A 与 B 是两个独立的对象，\n但 B 的初始值是由 A 对象确定的。在 Java 语言中，用简单的赋值语句是不能满足这种需求的。\n要满足这种需求虽然有很多途径，但实现 clone（）方法是其中最简单，也是最高效的手段。\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br")])]),t("details",{staticClass:"custom-block details"},[t("summary",[s._v("new一个对象")]),t("p",[s._v("new 操作符的本意是分配内存。\n程序执行到 new 操作符时，首先去看 new 操作符后面的类型，因为知道了类型， 才能知道要分配多大的内存空间。\n分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，\n构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。")])]),t("details",{staticClass:"custom-block details"},[t("summary",[s._v("clone一个对象")]),t("p",[s._v("clone 在第一步是和 new 相似的，都是分配内存，\n调用 clone 方法时，分配的内存和原对象（即调用 clone 方法的对象）相同，然后再使用原对象中对应的各个域，\n填充新对象的域，填充完成之后，clone 方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部。")])]),t("details",{staticClass:"custom-block details"},[t("summary",[s._v("案例 复制引用")]),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v('Person p = new Person(23, "zhang");\nPerson p1 = p;\nSystem.out.println(p);\nSystem.out.println(p1);\n\n结果：\ncom.itheima.Person@2f9ee1ac \ncom.itheima.Person@2f9ee1ac\n')])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br")])]),t("ul",[t("li",[s._v("可以看出，打印的地址值是相同的，既然地址都是相同的，那么肯定是同一个对象。p 和 p1 只是引用而已，他们都指向了一个相同的对象 Person(23, “zhang”) 。 可以把这种现象叫做引用的复制")])])]),t("details",{staticClass:"custom-block details"},[t("summary",[s._v("案例 复制对象")]),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v('Person p = new Person(23, "zhang");\nPerson p1 = (Person) p.clone(); \nSystem.out.println(p);\nSystem.out.println(p1);\n\n结果：\ncom.itheima.Person@2f9ee1ac\ncom.itheima.Person@67f1fba0\n')])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br")])]),t("ul",[t("li",[s._v("从打印结果可以看出，两个对象的地址是不同的，也就是说创建了新的对象， 而不是把原对象的地址赋给了一个新的引用变量")])])]),t("h2",{attrs:{id:"深拷贝与浅拷贝"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝与浅拷贝"}},[s._v("#")]),s._v(" 深拷贝与浅拷贝")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("public class Person implements Cloneable{ 2．privatint age ;\nprivate String name;\npublic Person(int age, String name){ \t\n\tthis.age = age;\n\tthis.name = name;\n\t}\npublic Person() {}\npublic int getAge(){ \n\treturn age;\n\t}\npublic String getName() {\n\treturn name;\n\t}\n@Override\nprotected Object clone() throws CloneNotSupportedException{\n\treturn (Person)super.clone();\n\t}\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br")])]),t("details",{staticClass:"custom-block details"},[t("summary",[s._v("说明")]),t("p",[s._v("由于 age 是基本数据类型，那么对它的拷贝没有什么疑议，直接将一个 4 字节的整数值拷贝过来就行。\n但是 name是 String 类型的， 它只是一个引用， 指向一个真正的 String 对象，\n那么对它的拷贝有两种方式： 直接将原对象中的 name 的引用值拷贝给新对象的 name 字段，\n或者是根据原 Person 对象中的 name 指向的字符串对象创建一个新的相同的字符串对象，\n将这个新字符串对象的引用赋给新拷贝的 Person 对象的 name 字段。这两种拷贝方式分别叫做浅拷贝和深拷贝。")])]),t("p",[s._v("待补充...")])],1)}),[],!1,null,null,null);n.default=e.exports}}]);