(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{449:function(s,n,a){"use strict";a.r(n);var e=a(2),t=Object(e.a)({},(function(){var s=this,n=s.$createElement,a=s._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"java集合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java集合"}},[s._v("#")]),s._v(" Java集合")]),s._v(" "),a("details",{staticClass:"custom-block details"},[a("summary",[s._v("面试题")]),a("p",[s._v("已知一个 HashMap<Integer，User>集合， User 有 name（String）和 age（int）属性。\n请写一个方法实现对HashMap 的排序功能，该方法接收 HashMap<Integer，User>为形参，返回类型为 HashMap<Integer，User>，\n要求对 HashMap 中的 User 的 age 倒序进行排序。\n排序时 key=value 键值对不得拆散。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('注意：要做出这道题必须对集合的体系结构非常的熟悉。\nHashMap 本身就是不可排序的，但是该道题偏偏让给 HashMap 排序，\n那我们就得想在 API 中有没有这样的 Map 结构是有序的，LinkedHashMap，对的，就是他，\n他是 Map 结构，也是链表结构，有序的，更可喜的是他是 HashMap 的子类，\n我们返回 LinkedHashMap<Integer,User>即可，还符合面向接口\n（父类编程的思想）。\n但凡是对集合的操作，我们应该保持一个原则就是能用 JDK 中的 API 就有 JDK 中的 API，\n比如排序算法我们不应 该去用冒泡或者选择，而是首先想到用 Collections 集合工具类。\n\npublic class HashMapTest {\npublic static void main(String[] args) {\nHashMap<Integer, User> users = new HashMap<>();\nusers.put(1, new User("张三", 25));\nusers.put(3, new User("李四", 22));\nusers.put(2, new User("王五", 28));\nSystem.out.println(users);\nHashMap<Integer,User> sortHashMap = sortHashMap(users);\nSystem.out.println(sortHashMap);\n\t/**\n* 控制台输出内容\n* {1=User [name=张三, age=25], 2=User [name=王五, age=28], 3=User [name=李四, age=22]}\n{2=User [name=王五, age=28], 1=User [name=张三, age=25], 3=User [name=李四, age=22]}\n\t*/\n } \n public static HashMap<Integer, User> sortHashMap(HashMap<Integer, User> map)\n{ \t// 首先拿到 map 的键值对集合\nSet<Entry<Integer, User>> entrySet = map.entrySet(); 20.\n// 将 set 集合转为 List 集合，为什么，为了使用工具类的排序方法\nList<Entry<Integer, User>> list = new ArrayList<Entry<Integer, User>>(entrySet);\n// 使用 Collections 集合工具类对 list 进行排序，排序规则使用匿名内部类来实现\nCollections.sort(list, new Comparator<Entry<Integer, User>>()\n{ \n@Override\npublic int compare(Entry<Integer, User> o1, Entry<Integer, User> o2)\n{ \t//按照要求根据 User 的 age 的倒序进行排\n\treturn o2.getValue().getAge()-o1.getValue().getAge();\n\t}\n\t});\n//创建一个新的有序的 HashMap 子类的集合\nLinkedHashMap<Integer, User> linkedHashMap = new LinkedHashMap<Integer, User>();\n//将 List 中的数据存储在 LinkedHashMap 中\nfor(Entry<Integer, User> entry : list){\nlinkedHashMap.put(entry.getKey(), entry.getValue());\n\t}\n\t//返回结果\n\treturn linkedHashMap;\n }\n} \n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br"),a("span",{staticClass:"line-number"},[s._v("32")]),a("br"),a("span",{staticClass:"line-number"},[s._v("33")]),a("br"),a("span",{staticClass:"line-number"},[s._v("34")]),a("br"),a("span",{staticClass:"line-number"},[s._v("35")]),a("br"),a("span",{staticClass:"line-number"},[s._v("36")]),a("br"),a("span",{staticClass:"line-number"},[s._v("37")]),a("br"),a("span",{staticClass:"line-number"},[s._v("38")]),a("br"),a("span",{staticClass:"line-number"},[s._v("39")]),a("br"),a("span",{staticClass:"line-number"},[s._v("40")]),a("br"),a("span",{staticClass:"line-number"},[s._v("41")]),a("br"),a("span",{staticClass:"line-number"},[s._v("42")]),a("br"),a("span",{staticClass:"line-number"},[s._v("43")]),a("br"),a("span",{staticClass:"line-number"},[s._v("44")]),a("br"),a("span",{staticClass:"line-number"},[s._v("45")]),a("br"),a("span",{staticClass:"line-number"},[s._v("46")]),a("br"),a("span",{staticClass:"line-number"},[s._v("47")]),a("br"),a("span",{staticClass:"line-number"},[s._v("48")]),a("br")])])]),a("h2",{attrs:{id:"集合的安全性问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#集合的安全性问题"}},[s._v("#")]),s._v(" 集合的安全性问题")]),s._v(" "),a("ul",[a("li",[s._v("请问 ArrayList、HashSet、HashMap 是线程安全的吗？如果不是我想要线程安全的集合怎么办？")]),s._v(" "),a("li",[s._v("我们都看过上面那些集合的源码（如果没有那就看看吧），每个方法都没有加锁，显然都是线程不安全的。")]),s._v(" "),a("li",[s._v("话又说过来如果他们安全了也就没第二问了。")]),s._v(" "),a("li",[s._v("在集合中 Vector 和 HashTable 倒是线程安全的。")]),s._v(" "),a("li",[s._v("你打开源码会发现其实就是把各自核心方法添加上了synchronized 关键字。")]),s._v(" "),a("li",[s._v("Collections 工具类提供了相关的 API，可以让上面那 3 个不安全的集合变为安全的。")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("Collections.synchronizedCollection(c\n)\nCollections.synchronizedList(list)\nCollections.synchronizedMap(m)\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("ul",[a("li",[s._v("上面几个函数都有对应的返回值类型，传入什么类型返回什么类型。")]),s._v(" "),a("li",[s._v("打开源码其实实现原理非常简单，就是将集合的核心方法添加上了 synchronized 关键字。")])]),s._v(" "),a("h2",{attrs:{id:"arraylist-内部实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#arraylist-内部实现"}},[s._v("#")]),s._v(" ArrayList 内部实现")]),s._v(" "),a("p",[s._v("（回答这样的问题，不要只回答个皮毛，可以再介绍一下 ArrayList 内部是如何实现数组的增加和删除的，因为\n数 组在创建的时候长度是固定的，那么就有个问题我们往 ArrayList 中不断的添加对象，它是如何管理这些数组呢？）")]),s._v(" "),a("ul",[a("li",[s._v("ArrayList 内部是用 Object[]实现的。接下来我们分别分析 ArrayList 的构造、add、remove、clear 方法的实现原理。")])]),s._v(" "),a("p",[s._v("一、构造函数\n1）空参构造")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("/**\n* Constructs a new {@code ArrayList} instance with zero initial capacity.\n*/\npublic ArrayList() {\narray = EmptyArray.OBJECT;\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("ul",[a("li",[s._v("array 是一个 Object[]类型。")]),s._v(" "),a("li",[s._v("当我们 new 一个空参构造时系统调用了 EmptyArray.OBJECT 属性，EmptyArray 仅仅是一个系统的类库，该类源码如下：")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("public final class EmptyArray\n{ private EmptyArray() {}\n\n\npublic static final boolean[] BOOLEAN = new boolean[0]; public static final byte[] BYTE = new byte[0];\npublic static final char[] CHAR = new char[0]; public static final double[] DOUBLE = new double[0]; public static final int[] INT = new int[0];\n\npublic static final Class<?>[] CLASS = new Class[0]; public static final Object[] OBJECT = new Object[0]; public static final String[] STRING = new String[0];\npublic static final Throwable[] THROWABLE = new Throwable[0];\npublic static final StackTraceElement[] STACK_TRACE_ELEMENT = new StackTraceElement[0];\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br")])]),a("ul",[a("li",[s._v("也就是说当我们 new 一个空参 ArrayList 的时候，系统内部使用了一个 new Object[0]数组。")]),s._v(" "),a("li",[s._v("2）带参构造1")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('/**\n*Constructs a new instance of {@code ArrayList} with the specified\n*initial capacity.\n*\n*@param capacity\n*the initial capacity of this {@code ArrayList}.\n*/\npublic ArrayList(int capacity)\n{ if (capacity < 0) {\nthrow new IllegalArgumentException("capacity < 0: " + capacity);\n}\narray = (capacity == 0 ? EmptyArray.OBJECT : new Object[capacity]);\n}\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br")])]),a("ul",[a("li",[s._v("该构造函数传入一个 int 值，该值作为数组的长度值。如果该值小于 0，则抛出一个运行时异常。如果等于 0，则使用一个空数组，如果大于 0，则创建一个长度为该值的新数组。")]),s._v(" "),a("li",[s._v("3）带参构造 2")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('/**\n*Constructs a new instance of {@code ArrayList} containing the elements of\n*the specified collection.\n*\n*@param collection\n*the collection of elements to add.\n*/\npublic ArrayList(Collection<? extends E> collection)\n{ if (collection == null) {\nthrow new NullPointerException("collection == null");\n}\n\n\nObject[] a = collection.toArray(); if (a.getClass() != Object[].class)\n{ Object[] newArray = new Object[a.length];\nSystem.arraycopy(a, 0, newArray, 0, a.length); a = newArray;\n}\narray = a;\nsize = a.length;\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br")])]),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("如果调用构造函数的时候传入了一个 Collection 的子类，那么先判断该集合是否为 null，为 null 则抛出空指针异常。\n如果不是则将该集合转换为数组 a，然后将该数组赋值为成员变量 array，将该数组的长度作为成员变量 size。\n这里面它先判断 a.getClass 是否等于 Object[].class，其实一般都是相等的，我也暂时没想明白为什么多加了这个判断， toArray 方法是 Collection 接口定义的，因此其所有的子类都有这样的方法，list 集合的 toArray 和 Set 集合的 toArray返回的都是 Object[]数组。\n这里讲些题外话，其实在看 Java 源码的时候，作者的很多意图都很费人心思，我能知道他的目标是啥，但是不知道他为何这样写。\n比如对于 ArrayList， array 是他的成员变量，但是每次在方法中使用该成员变量的时候作者都会重新在方法中开辟一个局部变量，\n然后给局部变量赋值为 array，然后再使用，有人可能说这是为了防止并发修改 array， \n毕竟 array 是成员变量，大家都可以使用因此需要将 array 变为局部变量，然后再使用，这样的说法并不是都成立的，\n 也许有时候就是老外们写代码的一个习惯而已。\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("p",[s._v("二、add 方法\nadd 方法有两个重载，这里只研究最简单的那个。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("/**\n*Adds the specified object at the end of this {@code ArrayList}.\n*\n*@param object\n*the object to add.\n*@return always true\n*/\n@Override public boolean add(E object)\n{ Object[] a = array; int s = size;\nif (s == a.length) {\nObject[] newArray = new Object[s +\n(s < (MIN_CAPACITY_INCREMENT / 2) ? MIN_CAPACITY_INCREMENT : s >> 1)];\nSystem.arraycopy(a, 0, newArray, 0, s); array = a = newArray;\n}\na[s] = object; size = s + 1; modCount++; return true;\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br")])]),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("1、首先将成员变量 array 赋值给局部变量 a，将成员变量 size 赋值给局部变量 s。\n2、判断集合的长度 s 是否等于数组的长度（如果集合的长度已经等于数组的长度了，说明数组已经满了，该重新分配新数 组了）， 重新分配 数组的时 候需要计 算新分配 内存的空 间大小， 如果当前 的长度小 于MIN_CAPACITY_INCREMENT/2（这个常量值是 12，除以 2 就是 6，也就是如果当前集合长度小于 6）则分配 12 个长度，如果集合长度大于 6 则分配当前长度 s 的一半长度。这里面用到了三元运算符和位运算，s >> 1，意思就是将\ns 往右移 1 位，相当于 s=s/2，只不过位运算是效率最高的运算。\n3、将新添加的 object 对象作为数组的 a[s]个元素。\n4、修改集合长 度 size 为 s+1\n5、modCotun++,该变量是父类中声明的，用于记录集合修改的次数，记录集合修改的次数是为了防止在用迭代 器迭代集合时避免并发修改异常，或者说用于判断是否出现并发修改异常的。\n6、return true，这个返回值意义不大，因为一直返回 true，除非报了一个运行时异常。 \n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("p",[s._v("三、remove 方法\nremove 方法有两个重载，我们只研究 remove（int index）方法。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('/**\n*Removes the object at the specified location from this list.\n*\n*@param index\n*the index of the object to remove.\n*@return the removed object.\n*@throws IndexOutOfBoundsException\n*when {@code location < 0 || location >= size()}\n*/\n@Override public E remove(int index)\n{ Object[] a = array; int s = size;\nif (index >= s)\n{ throwIndexOutOfBoundsException(index, s);\n}\n@SuppressWarnings("unchecked") E result = (E) a[index];\nSystem.arraycopy(a, index + 1, a, index, --s - index); a[s] = null; // Prevent memory leak\nsize = s; modCount++;\nreturn result;\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br")])]),a("p",[s._v("1、先将成员变量 array 和 size 赋值给局部变量 a 和 s。\n2、判断形参 index 是否大于等于集合的长度，如果成了则抛出运行时异常\n3、获取数组中脚标为 index 的对象 result，该对象作为方法的返回值\n4、调用 System 的 arraycopy 函数，拷贝原理如下图所示。")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/li-wen-kai/picgo/raw/master/img/image-20210601115116897.png",alt:"image-20210601115116897"}})]),s._v(" "),a("p",[s._v("5、接下来就是很重要的一个工作，因为删除了一个元素，而且集合整体向前移动了一位，因此需要将集合最后一 个元素设置为 null，否则就可能内存泄露。\n6、重新给成员变量 array 和 size 赋值\n7、记录修改次数\n8、返回删除的元素（让用户再看最后一眼）")]),s._v(" "),a("p",[s._v("四、clear 方法")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("/**\n*Removes all elements from this {@code ArrayList}, leaving it empty.\n*\n*@see #isEmpty\n*@see #size\n*/\n@Override public void clear()\n{ if (size != 0) {\nArrays.fill(array, 0, size, null); size = 0;\nmodCount++;\n}\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br")])]),a("p",[s._v("如果集合长度不等于 0，则将所有数组的值都设置为 null，然后将成员变量 size 设置为 0 即可，最后让修改记录加 1。")]),s._v(" "),a("p",[s._v("4.并发集合和普通集合如何区别？")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("并发集合常见的有 ConcurrentHashMap、ConcurrentLinkedQueue、ConcurrentLinkedDeque 等。\n并发集合 位 于\tjava.util.concurrent\t包 下 ， 是\tjdk1.5之 后 才 有 的 ， 主 要 作 者 是\tDougLea（http://baike.baidu.com/view/3141057.htm）完成的。\n在 java 中有普通集合、同步（线程安全）的集合、并发集合。\n普通集合通常性能最高，但是不保证多线程的安全性和并发的可靠性。\n线程安全集合仅仅是给集合添加了 synchronized 同步锁，严重牺牲了性能，而且对并发的效率就更低了，并发集合则通过复杂的策略不仅保证了多线程的安全又提高的并发时的效率。\n参考阅读：\nConcurrentHashMap 是线程安全的 HashMap 的实现，默认构造同样有 initialCapacity 和 loadFactor 属性， 不过还多了一个 concurrencyLevel 属性，三属性默认值分别为 16、0.75 及 16。其内部使用锁分段技术，维持这锁Segment 的数组，在 Segment 数组中又存放着 Entity[]数组，内部 hash 算法将数据较均匀分布在不同锁中。\nput 操作：并没有在此方法上加上 synchronized，首先对 key.hashcode 进行 hash 操作，得到 key 的 hash 值。hash 操作的算法和map 也不同，根据此 hash 值计算并获取其对应的数组中的 Segment 对象(继承自 ReentrantLock)， 接着调用此 Segment 对象的 put 方法来完成当前操作。\nConcurrentHashMap 基于 concurrencyLevel 划分出了多个 Segment 来对 key-value 进行存储，从而避免每 次 put 操作都得锁住整个数组。在默认的情况下，最佳情况下可允许 16 个线程并发无阻塞的操作集合对象，尽可能地 减少并发时的阻塞现象。\nget(key)\n首先对 key.hashCode 进行 hash 操作，基于其值找到对应的 Segment 对象，调用其 get 方法完成当前操作。\n而 Segment 的 get 操作首先通过 hash 值和对象数组大小减 1 的值进行按位与操作来获取数组上对应位置的HashEntry。\n在这个步骤中，可能会因为对象数组大小的改变，以及数组上对应位置的 HashEntry 产生不一致性，那么 ConcurrentHashMap 是如何保证的？\n对象数组大小的改变只有在 put 操作时有可能发生，由于 HashEntry 对象数组对应的变量是 volatile 类型的，因此可以保证如 HashEntry 对象数组大小发生改变，读操作可看到最新的对象数组大小。\n在获取到了 HashEntry 对象后，怎么能保证它及其 next 属性构成的链表上的对象不会改变呢？这点ConcurrentHashMap 采用了一个简单的方式，即 HashEntry 对象中的 hash、key、next 属性都是 final 的，这也就意味着没办法插入一个 HashEntry 对象到基于 next 属性构成的链表中间或末尾。\n这样就可以保证当获取到 HashEntry 对象后，其基于 next 属性构建的链表是不会发生变化的。\nConcurrentHashMap 默认情况下采用将数据分为 16 个段进行存储，并且 16 个段分别持有各自不同的锁Segment，锁仅用于 put 和 remove 等改变集合对象的操作，基于 volatile 及 HashEntry 链表的不变性实现了读取的不加锁。\n这些方式使得 ConcurrentHashMap 能够保持极好的并发支持，尤其是对于读远比插入和删除频繁的 Map 而言，而它采用的这些方法也可谓是对于 Java 内存模型、并发机制深刻掌握的体现。\n推荐博客地址：http://m.oschina.net/blog/269037\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br")])]),a("p",[s._v("5.List 的三个子类的特点")]),s._v(" "),a("ul",[a("li",[s._v("ArrayList  底层结构是数组,底层查询快,增删慢。")]),s._v(" "),a("li",[s._v("LinkedList 底层结构是链表型的,增删快,查询慢。")]),s._v(" "),a("li",[s._v("voctor\t 底层结构是数组 线程安全的,增删慢,查询慢。")])]),s._v(" "),a("p",[s._v("6.List 和 Map、Set 的区别")]),s._v(" "),a("details",{staticClass:"custom-block details"},[a("summary",[s._v("6.1结构特点")]),a("ul",[a("li",[s._v("List 和 Set 是存储单列数据的集合，Map 是存储键和值这样的双列数据的集合；")]),s._v(" "),a("li",[s._v("List 中存储的数据是有顺序，并且允许重复；")]),s._v(" "),a("li",[s._v("Map 中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的，")]),s._v(" "),a("li",[s._v("Set 中存储的数据是无序的，且不允许有重复，但元素在集合中的位置由元素的 hashcode 决定，位置是固定的（Set 集合根据 hashcode 来进行数据的存储，所以位置是固定的，但是位置不是用户可以控制的，所以对于用户来说 set 中的元素还是无序的）；")])])]),a("details",{staticClass:"custom-block details"},[a("summary",[s._v("6.2实现类")]),a("ul",[a("li",[s._v("List 接口有三个实现类（LinkedList：基于链表实现，链表内存是散乱的，每一个元素存储本身内存地址的同时还存储下一个元素的地址。链表增删快，查找慢；ArrayList：基于数组实现，非线程安全的，效率高，便于索引，但不便于插入删除；Vector：基于数组实现，线程安全的，效率低）。")]),s._v(" "),a("li",[s._v("Map 接口有三个实现类（HashMap：基于 hash 表的 Map 接口实现，非线程安全，高效，支持 null 值和 null 键；HashTable：线程安全，低效，不支持 null 值和 null 键；LinkedHashMap：是 HashMap 的一个子类，保存了记录的插入顺序；SortMap 接口：TreeMap，能够把它保存的记录根据键排序，默认是键值的升序排序）。")]),s._v(" "),a("li",[s._v("Set 接口有两个实现类（HashSet：底层是由 HashMap 实现，不允许集合中有重复的值，使用该方式时需要重写 equals()和 hashCode()方法；LinkedHashSet：继承与 HashSet，同时又基于 LinkedHashMap 来进行实现，底层使用的是 LinkedHashMp）。")])])]),a("details",{staticClass:"custom-block details"},[a("summary",[s._v("6.3区别")]),a("ul",[a("li",[s._v("List 集合中对象按照索引位置排序，可以有重复对象，允许按照对象在集合中的索引位置检索对象，例如通过list.get(i)方法来获取集合中的元素；")]),s._v(" "),a("li",[s._v("Map 中的每一个元素包含一个键和一个值，成对出现，键对象不可以重复，值对象可以重复；")]),s._v(" "),a("li",[s._v("Set 集合中的对象不按照特定的方式排序，并且没有重复对象，但它的实现类能对集合中的对象按照特定的方式排序，例如 TreeSet 类，可以按照默认顺序，也可以通过实现 Java.util.Comparator"),a("Type",[s._v("接口来自定义排序方式。")])],1)])]),a("p",[s._v("7.HashMap 和 HashTable 有什么区别?")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("HashMap 是线程不安全的,HashMap 是一个接口,是 Map 的一个子接口,是将键映射到值得对象,不允许键值重复, 允许空键和空值;\n由于非线程安全,HashMap 的效率要较 HashTable 的效率高一些.\nHashTable 是线程安全的一个集合,不允许 null 值作为一个 key 值或者 Value 值;\nHashTable 是 sychronize,多个线程访问时不需要自己为它的方法实现同步,而 HashMap 在被多个线程访问的时候需要自己为它的方法实现同步;\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("8.数组和链表分别比较适合用于什么场景，为什么？")]),s._v(" "),a("details",{staticClass:"custom-block details"},[a("summary",[s._v("8.1数组和链表简介")]),a("p",[s._v("在计算机中要对给定的数据集进行若干处理，首要任务是把数据集的一部分（当数据量非常大时，可能只能一部分一部分地读取数据到内存中来处理）或全部存储到内存中，然后再对内存中的数据进行各种处理。\n例如，对于数据集 S{1，2，3，4，5，6}，要求 S 中元素的和，首先要把数据存储到内存中，然后再将内存中的数据相加。\n当内存空间中有足够大的连续空间时，可以把数据连续的存放在内存中，各种编程语言中的数组一般都是按这种\n方式存储的（也可能有例外），如图 1（b）；当内存中只有一些离散的可用空间时，想连续存储数据就非常困难了，\n这时能想到的一种解决方式是移动内存中的数据，把离散的空间聚集成连续的一块大空间，如图 1（c）所示，这样做\n当然也可以，但是这种情况因为可能要移动别人的数据，所以会存在一些困难，移动的过程中也有可能会把一些别人的重要数据给丢失。\n另外一种，不影响别人的数据存储方式是把数据集中的数据分开离散地存储到这些不连续空间中， 如图（d）。\n这时为了能把数据集中的所有数据联系起来，需要在前一块数据的存储空间中记录下一块数据的地址，这样只要知道第一块内存空间的地址就能环环相扣地把数据集整体联系在一起了。\nC/C++中用指针实现的链表就是这种存储形式。")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/li-wen-kai/picgo/raw/master/img/image-20210601120204057.png",alt:"image-20210601120204057"}})]),s._v(" "),a("p",[s._v("由上可知，内存中的存储形式可以分为连续存储和离散存储两种。因此，数据的物理存储结构就有连续存储和离散存储两种，它们对应了我们通常所说的数组和链表，")])]),a("details",{staticClass:"custom-block details"},[a("summary",[s._v("8.2数组和链表的区别")]),a("p",[s._v("数组是将元素在内存中连续存储的；它的优点：因为数据是连续存储的，内存地址连续，所以在查找数据的时候效率比较高；\n它的缺点：在存储之前，我们需要申请一块连续的内存空间，并且在编译的时候就必须确定好它的空间的大小。\n在运行的时候空间的大小是无法随着你的需要进行增加和减少而改变的，\n当数据两比较大的时候，有可能会出现越界的情况，数据比较小的时候，又有可能会浪费掉内存空间。\n在改变数据个数时，增加、插入、删除数据效率比较低链表是动态申请内存空间，不需要像数组需要提前申请好内存的大小，\n链表只需在用的时候申请就可以，根据需 要来动态申请或者删除内存空间，对于数据增加和删除以及插入比数组灵活。\n还有就是链表中数据在内存中可以在任意的位置，通过应用来关联数据（就是通过存在元素的指针来联系）")])]),a("details",{staticClass:"custom-block details"},[a("summary",[s._v("8.3链表和数组使用场景")]),a("p",[s._v("数组应用场景：数据比较少；经常做的运算是按序号访问数据元素；数组更容易实现，任何高级语言都支持；\n构建的线性表较稳定。\n链表应用场景：对线性表的长度或者规模难以估计；频繁做插入删除操作；\n构建动态性比较强的线性表。\n参考博客：http://blog.csdn.net/u011277123/article/details/53908387")])]),a("details",{staticClass:"custom-block details"},[a("summary",[s._v("8.4跟数组相关的面试题")]),a("p",[s._v("用面向对象的方法求出数组中重复 value 的个数，按如下个数输出：")]),s._v(" "),a("ul",[a("li",[s._v("1 出现：1 次")]),s._v(" "),a("li",[s._v("3 出现：2 次")]),s._v(" "),a("li",[s._v("8 出现：3 次")]),s._v(" "),a("li",[s._v("2 出现：4 次")]),s._v(" "),a("li",[s._v("int[] arr = {1,4,1,4,2,5,4,5,8,7,8,77,88,5,4,9,6,2,4,1,5};")])])]),a("p",[s._v("9.Java 中 ArrayList 和 Linkedlist 区别？")]),s._v(" "),a("ul",[a("li",[s._v("ArrayList 和 Vector 使用了数组的实现，可以认为 ArrayList 或者 Vector 封装了对内部数组的操作，比如向数组中添加，删除，插入新的元素或者数据的扩展和重定向。")]),s._v(" "),a("li",[s._v("LinkedList 使用了循环双向链表数据结构。与基于数组的 ArrayList 相比，这是两种截然不同的实现技术，这也决定了它们将适用于完全不同的工作场景。")]),s._v(" "),a("li",[s._v("LinkedList 链表由一系列表项连接而成。一个表项总是包含 3 个部分：元素内容，前驱表和后驱表，如图所示：")])]),s._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/li-wen-kai/picgo/raw/master/img/image-20210601120519840.png",alt:"image-20210601120519840"}})]),s._v(" "),a("ul",[a("li",[s._v("在下图展示了一个包含 3 个元素的 LinkedList 的各个表项间的连接关系。")]),s._v(" "),a("li",[s._v("在 JDK 的实现中，无论 LikedList 是否为空，链表内部都有一个 header 表项，它既表示链表的开始，也表示链表的结尾。")]),s._v(" "),a("li",[s._v("表项 header 的后驱表项便是链表中第一个元素，表项 header 的前驱表项便是链表中最后一个元素。")])]),s._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/li-wen-kai/picgo/raw/master/img/image-20210601120610964.png",alt:"image-20210601120610964"}})]),s._v(" "),a("p",[s._v("10.List a=new ArrayList()和 ArrayList a =new ArrayList()的区别？")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("List list = new ArrayList();这句创建了一个 ArrayList 的对象后把上溯到了 List。\n此时它是一个 List 对象了，有些ArrayList 有但是 List 没有的属性和方法，它就不能再用了。\n而 ArrayList list=new ArrayList();创建一对象则保留了ArrayList 的所有属性。\n所以需要用到 ArrayList 独有的方法的时候不能用前者。实例代码如下：\nList list = new ArrayList(); \nArrayList arrayList = new ArrayList(); \nlist.trimToSize(); //错误，没有该方法。\narrayList.trimToSize();\t//ArrayList 里有该方法。\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("p",[s._v("11.要对集合更新操作时，ArrayList 和 LinkedList 哪个更适合？")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('1.ArrayList 是实现了基于动态数组的数据结构，LinkedList 基于链表的数据结构。\n2.如果集合数据是对于集合随机访问 get 和 set，ArrayList 绝对优于 LinkedList，因为 LinkedList 要移动指针。\n3.如果集合数据是对于集合新增和删除操作 add 和 remove，LinedList 比较占优势，\n因为 ArrayList 要移动数据。ArrayList 和 LinkedList 是两个集合类，用于存储一系列的对象引用(references)。\n例如我们可以用 ArrayList 来存储一系列的 String 或者 Integer。\n那 么 ArrayList 和 LinkedList 在性能上有什么差别呢？什么时候应该用 ArrayList 什么时候又该用 LinkedList 呢？\n一．时间复杂度\n首先一点关键的是，ArrayList 的内部实现是基于基础的对象数组的，\n因此，它使用 get 方法访问列表中的任意一个元素时(random access)，它的速度要比 LinkedList 快。\nLinkedList 中的 get 方法是按照顺序从列表的一端开始检查，直到另外一端。\n对 LinkedList 而言，访问列表中的某个指定元素没有更快的方法了。\n假设我们有一个很大的列表，它里面的元素已经排好序了，\n这个列表可能是 ArrayList 类型的也可能是 LinkedList 类型的，\n现在我们对这个列表来进行二分查找(binary search)，比较列表是 ArrayList 和 LinkedList 时的查询速度，\n看下面的程序：\npublic class TestList{\n\tpublic static final int N=50000;\t//50000 个数\n\tpublic static List values;\n\t//放入 50000 个数给 value； static{\n\tInteger vals[]=new Integer[N];\n\tRandom r=new Random();\n\tfor(int i=0,currval=0;i<N;i++)...{\n\t\tvals=new Integer(currval);\n\t    currval+=r.nextInt(100)+1;\n\t}\n\t}\n\t//通过二分查找法查找\n\tstatic long timeList(List lst){\n\tlong start=System.currentTimeMillis(); for(int i=0;i<N;i++)...{\n\tint index=Collections.binarySearch(lst, values.get(i)); if(index!=i)\n\tSystem.out.println("***错误***");\n\t}\n\treturn System.currentTimeMillis()-start;\n\t}\n\tpublic static void main(String args[])...{\n\tSystem.out.println("ArrayList 消耗时间："+timeList(new ArrayList(values)));\n\tSystem.out.println("LinkedList 消耗时间："+timeList(new LinkedList(values)));\n\t\n\t得到的输出是：\n\tArrayList 消耗时间：15\n\tLinkedList 消耗时间：2596\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br"),a("span",{staticClass:"line-number"},[s._v("32")]),a("br"),a("span",{staticClass:"line-number"},[s._v("33")]),a("br"),a("span",{staticClass:"line-number"},[s._v("34")]),a("br"),a("span",{staticClass:"line-number"},[s._v("35")]),a("br"),a("span",{staticClass:"line-number"},[s._v("36")]),a("br"),a("span",{staticClass:"line-number"},[s._v("37")]),a("br"),a("span",{staticClass:"line-number"},[s._v("38")]),a("br"),a("span",{staticClass:"line-number"},[s._v("39")]),a("br"),a("span",{staticClass:"line-number"},[s._v("40")]),a("br"),a("span",{staticClass:"line-number"},[s._v("41")]),a("br")])]),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('这个结果不是固定的，但是基本上 ArrayList 的时间要明显小于 LinkedList 的时间。\n因此在这种情况下不宜用LinkedList。二分查找法使用的随机访问(random access)策略，\n而 LinkedList 是不支持快速的随机访问的。\n对一个LinkedList 做随机访问所消耗的时间与这个 list 的大小是成比例的。\n而相应的，在 ArrayList 中进行随机访问所消耗的时间是固定的。\n这是否表明 ArrayList 总是比 LinkedList 性能要好呢？\n这并不一定，在某些情况下 LinkedList 的表现要优于ArrayList，有些算法在 LinkedList 中实现 时效率更高。\n比方说，利用 Collections.reverse 方法对列表进行反转时， 其性能就要好些。\n看这样一个例子，加入我们有一个列表，要对其进行大量的插入和删除操作，在这种情况下 LinkedList 就是一个较好的选择。\n请看如下一个极端的例子，我们重复的在一个列表的开端插入一个元素：\nimport java.util.*; \npublic class ListDemo {\nstatic final int N=50000;\nstatic long timeList(List list){\nlong start=System.currentTimeMillis();\nObject o = new Object();\nfor(int i=0;i<N;i++)\nlist.add(0, o);\nreturn System.currentTimeMillis()-start;\n\t}\npublic static void main(String[] args) {\nSystem.out.println("ArrayList 耗时："+timeList(new ArrayList()));\nSystem.out.println("LinkedList 耗时："+timeList(new LinkedList()));\n\t}\n}\n\n这时我的输出结果是\nArrayList 耗时：2463\nLinkedList 耗时：15\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br")])]),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("二．空间复杂度\n在 LinkedList 中有一个私有的内部类，定义如下：\nprivate static class Entry {\n\tObject element;\n\tEntry next;\n\tEntry previous;\n\t}\n\n每个 Entry 对象 reference 列表 中的一个元素，同时还有在 LinkedList 中它的上一个元素和下一个元素。\n一个有 1000 个元素的 LinkedList 对象将有 1000 个链接在一起 的 Entry 对象，每个对象都对应于列表中的一个元素。\n这样的话，在一个 LinkedList 结构中将有一个很大的空间开销，因为它要存储这 1000 个 Entity 对象的相关信息。\nArrayList 使用一个内置的数组来存 储元素，这个数组的起始容量是 10.\n当数组需要增长时，新的容量按如下公式获得：新容量=(旧容量*3)/2+1，也就是说每一次容量大概会增长 50%。 \n这就意味着，如果你有一个包含大量元 素的ArrayList 对象，那么最终将有很大的空间会被浪费掉，\n这个浪费是由 ArrayList 的工作方式本身造成 的。如果 没有足够的空间来存放新的元素，\n数组将不得不被重新进行分配以便能够增加新的元素。对数组进行重新分配，将会导致性能急剧下降。\n如果我们知道一个 ArrayList 将会有多少个元素，我们可以通过构造方法来指定容量。\n我们还可以通过 trimToSize 方法在 ArrayList 分配完毕之后去掉浪 费掉的空间。\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br")])]),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("三．总结\nArrayList 和 LinkedList 在性能上各有优缺点，都有各自所适用的地方，总的说来可以描述如下：\n1.对 ArrayList 和 LinkedList 而言，在列表末尾增加一个元素所花的开销都是固定的。对 ArrayList 而言，主要是在内部数组中增加一项，指向所添加的元素，偶 尔可能会导致对数组重新进行分配；而对 LinkedList 而言，这个开销是统一的，分配一个内部 Entry 对象。\n2.在 ArrayList 的中间插入或删除一个元素意味着这个列表中剩余的元素都会被移动；而在 LinkedList 的中间插入或删除一个元素的开销是固定的。\n3.LinkedList 不支持高效的随机元素访问。\n4.ArrayList 的空间浪费主要体现在在 list 列表的结尾预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗相当的空间\n可以这样说：当操作是在一列数据的后面添加数据而不是在前面或中间,并且需要随机地访问其中的元素时,使用ArrayList 会提供比较好的性能；\n当你的操作是在一列数据的前面或中间添加或删除数据,并且按照顺序访问其中的元素时,就应该使用 LinkedList 了。\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("p",[s._v("12.请用两个队列模拟堆栈结构")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('两个队列模拟一个堆栈，队列是先进先出，而堆栈是先进后出。模拟如下 队列 a 和 b\n（1）入栈：a 队列为空，b 为空。例：则将”a,b,c,d,e”需要入栈的元素先放 a 中，a 进栈为”a,b,c,d,e”\n（2）出栈：a 队列目前的元素为”a,b,c,,d,e”。将 a 队列依次加入 Arraylist 集合 a 中。\n以倒序的方法，将 a 中的集合取出，放入 b 队列中，再将 b 队列出列。代码如下：\n\npublic static void main(String[] args) {\nQueue<String> queue = new LinkedList<String>();//a 队列Queue<String> queue2=new LinkedList<String>(); //b 队列ArrayList<String> a=new ArrayList<String>();//arrylist 集合是中间参数\n//往 a 队列添加元素queue.offer("a");\nqueue.offer("b");\nqueue.offer("c");\nqueue.offer("d");\nqueue.offer("e"); System.out.print("进栈：");\n//a 队列依次加入 list 集合之中\nfor(String q : queue){ a.add(q); System.out.print(q);\n}\n\n//以倒序的方法取出（a 队列依次加入 list 集合）之中的值，加入 b 对列for(int i=a.size()-1;i>=0;i--){ queue2.offer(a.get(i));\n}\n//打印出栈队列 System.out.println(""); System.out.print("出栈：");\nfor(String q : queue2){ System.out.print(q);\n}\n\n打印结果为（遵循栈模式先进后出）：\n进栈：a b c d e\n出栈：e d c b a\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br")])]),a("p",[s._v("13.Collection 和 Map 的集成体系\nCollection:")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/li-wen-kai/picgo/raw/master/img/image-20210601121719207.png",alt:"image-20210601121719207"}})]),s._v(" "),a("p",[s._v("Map:")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/li-wen-kai/picgo/raw/master/img/image-20210601121753487.png",alt:"image-20210601121753487"}})]),s._v(" "),a("p",[s._v("14.Map 中的 key 和 value 可以为 null 么？")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('HashMap 对象的 key、value 值均可为 null。\nHahTable 对象的 key、value 值均不可为 null。\n且两者的的 key 值均不能重复，若添加 key 相同的键值对，后面的 value 会自动覆盖前面的 value，但不会报错。\n测试代码如下：\n\npublic class Test {\n\tpublic static void main(String[] args) {\n\tMap<String, String> map = new HashMap<String, String>();//HashMap 对象\n\tMap<String, String> tableMap = new Hashtable<String, String>();//HashTable 对象\n\tmap.put(null, null);\n\tSystem.out.println("hashMap 的[key]和[value]均可以为 null:" + map.get(null));\n\ttry {\n\ttableMap.put(null, "3"); System.out.println(tableMap.get(null));\n\t} catch (Exception e) { System.out.println("【ERROR】： hashTable 的[key]不能为 null");\n\t}\n\t\n\ttry {\n\ttableMap.put("3", null);\n\t\n\tSystem.out.println(tableMap.get("3"));\n\t} catch (Exception e) {\n\t\tSystem.out.println("【ERROR】：hashTable 的[value]不能为 null");\n\t\t}\n\t}\n}\n\n运行结果：\nhashMap 的[key]和[value]均可以为 null:null\n【ERROR】：hashTable 的[key]不能为 null\n【ERROR】：hashTable 的[value]不能为 null\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br")])])])}),[],!1,null,null,null);n.default=t.exports}}]);