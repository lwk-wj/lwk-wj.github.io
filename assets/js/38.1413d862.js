(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{451:function(s,a,n){"use strict";n.r(a);var e=n(2),t=Object(e.a)({},(function(){var s=this,a=s.$createElement,n=s._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h2",{attrs:{id:"概念"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[s._v("#")]),s._v(" 概念")]),s._v(" "),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("什么是线程和进程？")]),n("ul",[n("li",[s._v("进程\n程序的一次执行过程，或是正在运行的一个程序。\n说明：进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域")]),s._v(" "),n("li",[s._v("线程\n进程可进一步细化为线程，是一个程序内部的一条执行路径。\n线程作为资源调度和执行的基本单位，每个线程拥独立的运行栈和程序计数器(pc)，线程切换的开销小。")])])]),n("h2",{attrs:{id:"关系"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#关系"}},[s._v("#")]),s._v(" 关系")]),s._v(" "),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("线程与进程的关系")]),n("ul",[n("li",[s._v("JVM角度说明：\n"),n("img",{attrs:{src:"https://gitee.com/li-wen-kai/picgo/raw/master/img/20210708154803.png",alt:""}})]),s._v(" "),n("li",[s._v("结论：")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("一个进程中可以有多个线程，多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，\n但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈。\n\n线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。\n线程执行开销小，但不利于资源的管理和保护；而进程正相反。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])])]),n("h3",{attrs:{id:"扩展"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#扩展"}},[s._v("#")]),s._v(" 扩展")]),s._v(" "),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("为什么程序计数器、虚拟机栈和本地方法栈是线程私有?")]),n("ul",[n("li",[s._v("程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。")]),s._v(" "),n("li",[s._v("说明")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("程序计数器主要有下面两个作用：\n字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。\n在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。\n需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。\n所以，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])]),n("ul",[n("li",[s._v("虚拟机栈和本地方法栈线程私有是为了保证线程中的局部变量不被别的线程访问到。")]),s._v(" "),n("li",[s._v("说明")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("虚拟机栈： 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。\n从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。\n本地方法栈： 和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，\n而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。\n所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("一句话了解堆和方法区")]),n("ul",[n("li",[s._v("堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，")]),s._v(" "),n("li",[s._v("方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。")])])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("并发和并行的区别？")]),n("ul",[n("li",[s._v("并发：同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；")]),s._v(" "),n("li",[s._v("并行：单位时间内，多个任务同时执行。")]),s._v(" "),n("li",[s._v("详细解释")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("解释一：并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。\n解释二：并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。\n解释三：并行是在一台处理器上“同时”处理多个任务，并发是在多台处理器上同时处理多个任务。如 hadoop 分布式集群。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("说说线程的生命周期和状态?")]),n("ul",[n("li",[s._v("Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：")]),s._v(" "),n("li",[s._v("初始状态、运行状态、阻塞状态、等待状态、超时等待状态、终止状态\n"),n("img",{attrs:{src:"https://gitee.com/li-wen-kai/picgo/raw/master/img/20210708150714.png",alt:""}})]),s._v(" "),n("li",[s._v("线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换：\n"),n("img",{attrs:{src:"https://gitee.com/li-wen-kai/picgo/raw/master/img/20210708150817.png",alt:""}})])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("线程的生命周期一共分为五个部分分别是：新建，就绪，运行，阻塞以及死亡。\n由于cpu需要在多条线程中切换因此线程状态也会在多次运行和阻塞之间切换\n\n线程创建之后它将处于初始状态(NEW，新建)，调用 start() 方法后开始运行，线程这时候处于可运行状态(READY，就绪)。\n可运行状态的线程获得了 CPU 时间片后就处于 运行状态(RUNNING，运行)。\n当线程执行 wait()方法之后，线程进入 等待状态(WAITING)，进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态【notify()】。 而 超时等待状态(TIME_WAITING)相当于在等待状态的基础上增加了超时限制，【sleep（long millis）/wait（long millis）】，当超时时间到达后 Java 线程将会返回到运行状态。\n当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到阻塞状态(BLOCKED)。\n线程在执行 Runnable 的run()方法之后将会进入到 终止状态(TERMINATED)。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br")])])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("什么是上下文切换？")]),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。\n\n主动让出 CPU，比如调用了 sleep(), wait() 等。\n时间片用完，因为操作系统要防止一个线程或者进程长时间占用CPU导致其他线程或者进程饿死。\n调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。\n被终止或结束运行\n这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 上下文切换。\n\n上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br")])])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("创建线程的几种方式？")]),n("ul",[n("li",[s._v("有4种方式：继承Thread类、实现Runnable接口、实现Callable接口、使用Executor框架来创建线程池。")]),s._v(" "),n("li",[s._v("(1) 通过继承Thread类创建线程")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("public class MyThread extends Thread {//继承Thread类\n　　//重写run方法\n　　public void run(){\n　　}\n}\n----------------------------------------------------------------------------------\npublic class Main {\n　　public static void main(String[] args){\n　　　　new MyThread().start(); //创建并启动线程\n　　}\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br")])]),n("ul",[n("li",[s._v("(2)通过实现Runnable接口来创建线程")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("public class MyThread2 implements Runnable {//实现Runnable接口\n　　//重写run方法\n　　public void run(){\n　　}\n}\n------------------------------------------------------------------------------------------\npublic class Main {\n　　public static void main(String[] args){\n　　　　//创建并启动线程\n　　　　MyThread2 myThread=new MyThread2();\n　　　　Thread thread=new Thread(myThread);\n　　　　thread().start();\n　　　　//或者new Thread(new MyThread2()).start();\n　　}\n}\n\n不管是继承Thread还是实现Runnable接口，多线程代码都是通过运行Thread的start()方法来运行的。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br")])]),n("ul",[n("li",[s._v("实现Callable接口来创建线程")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('与实现Runnable接口类似，和Runnable接口不同的是，Callable接口提供了一个call() 方法作为线程执行体，call()方法比run()方法功能要强大：call()方法可以有返回值、call()方法可以声明抛出异常。\npublic class Main {\n　　public static void main(String[] args){\n　　　MyThread3 th=new MyThread3();\n　　　//使用Lambda表达式创建Callable对象\n　　   //使用FutureTask类来包装Callable对象\n　　　FutureTask<Integer> future=new FutureTask<Integer>(\n　　　　(Callable<Integer>)()->{\n　　　　　　return 5;\n　　　　}\n　　  );\n　　　new Thread(task,"有返回值的线程").start();//实质上还是以Callable对象来创建并启动线程\n　　  try{\n　　　　System.out.println("子线程的返回值："+future.get());//get()方法会阻塞，直到子线程执行结束才返回\n 　　 }catch(Exception e){\n　　　　ex.printStackTrace();\n　　　}\n　　}\n}\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br")])]),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("实现Runnable接口和Callable接口的区别？\n Runnable接口或Callable接口实现类都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行。两者的区别在于 Runnable 接口不会返回结果但是 Callable 接口可以返回结果。\n\n执行execute()方法和submit()方法的区别是什么呢？\n1) execute() 方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；\n\n2) submit() 方法用于提交需要返回值的任务。线程池会返回一个Future类型的对象，通过这个Future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br")])])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("sleep() 方法和 wait() 方法区别和共同点?")]),n("ul",[n("li",[s._v("相同点：")]),s._v(" "),n("li",[s._v("两者都可以暂停线程的执行，都会让线程进入等待状态。")]),s._v(" "),n("li",[s._v("不同点：")]),s._v(" "),n("li",[s._v("sleep()方法没有释放锁，而 wait()方法释放了锁。")]),s._v(" "),n("li",[s._v("sleep()方法属于Thread类的静态方法，作用于当前线程；而wait()方法是Object类的实例方法，作用于对象本身。")]),s._v(" "),n("li",[s._v("执行sleep()方法后，可以通过超时或者调用interrupt()方法唤醒休眠中的线程；")]),s._v(" "),n("li",[s._v("执行wait()方法后，通过调用notify()或notifyAll()方法唤醒等待线程。")])]),s._v(" "),n("p",[n("strong",[s._v("总结：最大的不同是在等待时 wait 会释放锁，而 sleep 一直持有锁。wait 通常被用于线程间交互，sleep 通常被用于暂停执行。")])])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？")]),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("new 一个 Thread，线程进入初始状态；\n调用 start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。\nstart() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 \n而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br")])]),n("ul",[n("li",[s._v("总结： 调用 start 方法可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。")])])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("synchronized 关键字和 volatile 关键字的区别")]),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("1）一旦一个共享变量（类的成员变量、类的静态成员变量）被 volatile 修饰之后，那么就具备了两层语义： 1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说\n是 立即可见的。\n2）禁止进行指令重排序。\nvolatile 本质是在告诉 jvm 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。\n1.volatile 仅能使用在变量级别；\nsynchronized 则可以使用在变量、方法、和类级别的2.volatile 仅能实现变量的修改可见性，并不能保证原子性；\nsynchronized 则可以保证变量的修改可见性和原子性3.volatile 不会造成线程的阻塞；\nsynchronized 可能会造成线程的阻塞。4.volatile 标记的变量不会被编译器优化； synchronized 标记的变量可以被编译器优化\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br")])])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("启动一个线程是调用run()方法还是start()方法？")]),n("p",[s._v("启动一个线程是调用 start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由 JVM 调度并执行，这并不意味着线程就会立即运行。\nrun()方法是线程启动后要进行回调（callback）的方法。")])])])}),[],!1,null,null,null);a.default=t.exports}}]);