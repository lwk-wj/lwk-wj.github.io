(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{453:function(s,a,n){"use strict";n.r(a);var e=n(2),t=Object(e.a)({},(function(){var s=this,a=s.$createElement,n=s._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h1",{attrs:{id:"java集合"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#java集合"}},[s._v("#")]),s._v(" java集合")]),s._v(" "),n("ul",[n("li",[s._v("集合、数组都是对多个数据进行存储操作的结构，简称Java容器。")]),s._v(" "),n("li",[s._v("集合概述：")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("JDK提供的集合API位于java.util包内\n主要有三种：set、list(列表中包含queue)、Map映射，\n每一种集合接口描述了一种数据结构。\n\n注意：java.util.Collections，是不属于java的集合框架的。它是一个集合的工具类。\n比如我们常用它的排序方法：Collections.sort(List), Collections.sort(List, Comparator)。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br")])]),n("ul",[n("li",[s._v("集合图解\n"),n("img",{attrs:{src:"https://gitee.com/li-wen-kai/picgo/raw/859d0ef611164329c1594251f504f56db8ae6474/img/0c130388a2b97b394b4c0e2d4b2356d2.png",alt:""}}),s._v(" "),n("img",{attrs:{src:"https://gitee.com/li-wen-kai/picgo/raw/master/img/d40a70942c9f61910fb649a9eb7538a7.JPEG",alt:""}})])]),s._v(" "),n("h2",{attrs:{id:"collection"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#collection"}},[s._v("#")]),s._v(" Collection")]),s._v(" "),n("ul",[n("li",[s._v("是集合List、Map、Queue最基本的接口")]),s._v(" "),n("li",[s._v("单列集合，用来存储一个一个的对象")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("Collection常用方法：\nadd(Object obj),\naddAll(Collection coll),\nsize(),\nisEmpty(),\nclear();\ncontains(Object obj),\ncontainsAll(Collection coll),\nremove(Object obj),\nremoveAll(Collection coll),\nretainsAll(Collection coll),\nequals(Object obj);\nhasCode(),\ntoArray(),\niterator();\n\n注意：使用Collection集合存储对象，要求对象所属的类满足：\n向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals().\n\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br")])]),n("p",[n("img",{attrs:{src:"https://gitee.com/li-wen-kai/picgo/raw/master/img/a22051f25acddf1b33e0e5b970e8a7d8.png",alt:""}})]),s._v(" "),n("h3",{attrs:{id:"list"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#list"}},[s._v("#")]),s._v(" List")]),s._v(" "),n("ul",[n("li",[s._v("存储序的、可重复的数据。  --\x3e“动态”数组,替换原的数组")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("List集合关心的元素是否有序，而不关心元素是否重复\nList接口是一个有序的 Collection，\n使用此接口能够精确的控制每个元素插入的位置，能够通过索引(元素在List中位置，类似于数组的下标)来访问List中的元素，\n第一个元素的索引为 0，而且允许有相同的元素。\n\n特点：\n   List 接口存储一组不唯一，有序（插入顺序）的对象。\n   \n常用方法：\n增：add(Object obj)\n删：remove(int index) / remove(Object obj)\n改：set(int index, Object ele)\n查：get(int index)\n插：add(int index, Object ele)\n长度：size()\n遍历：① Iterator迭代器方式\n     ② 增强for循环\n     ③ 普通的循环\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br")])]),n("ul",[n("li",[s._v("list是一个有序的collection")]),s._v(" "),n("li",[s._v("list一共三个实现类：ArrayList、LinkList、Vector")])]),s._v(" "),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("ArrayList(数组)")]),n("ul",[n("li",[s._v("线程不安全的，效率高；底层使用Object[] elementData存储\nArrayList 是最常用的 List 实现类，内部是通过动态数组实现的，它允许对元素进行快速随机访问。\n数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。\n当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。")])]),s._v(" "),n("p",[s._v("使用场景：适合随机查找和遍历，不适合插入和删除。")])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("LinkList(链表)")]),n("ul",[n("li",[s._v("对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储\nLinkedList 是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较\n慢。另外，他还提供了 List 接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆\n栈、队列和双向队列使用")])]),s._v(" "),n("p",[s._v("使用场景：适合数据的动态插入和删除，不适合随机访问和遍历速度")])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("Vector(数组实现、线程同步)")]),n("ul",[n("li",[s._v("线程安全的，效率低；底层使用Object[] elementData存储\nVector 与 ArrayList 一样，也是通过数组实现的，\n不同的是它支持线程的同步，即某一时刻只有一个线程能够写 Vector，避免多线程同时写而引起的不一致性，\n但实现同步需要很高的花费，因此，访问它比访问 ArrayList 慢。")])])]),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("ArrayList访问元素速度优于LinkedList，\nLinkedList占用的内存空间比较大，但LinkedList在批量插入或删除数据时优于ArrayList。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br")])]),n("h3",{attrs:{id:"set"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[s._v("#")]),s._v(" Set")]),s._v(" "),n("ul",[n("li",[s._v("存储无序的、不可重复的数据")]),s._v(" "),n("li",[s._v("存储的数据在底层数组中并非照数组索引的顺序添加，而是根据数据的哈希值决定的。")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("Set 具有与 Collection 完全一样的接口，只是行为上不同，Set 不保存重复的元素。\n\nSet 注重独一无二的性质,该集合用于存储无序(存入和取出的顺序不一定相同)元素，值不能重复。\n对象的相等性本质是对象 hashCode 值（java 是依据对象的内存地址计算出的此序号）判断的，\n如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的 hashCode 方法和 equals 方法。\n\n常用方法：Set接口中没额外定义新的方法，使用的都是Collection中声明过的方法。\n特点：\n   Set 接口存储一组唯一，无序的对象。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br")])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("HashSet（Hash 表）")]),n("ul",[n("li",[s._v("Set接口的主要实现类；线程不安全的；可以存储null值，底层：数组+链表结构")]),s._v(" "),n("li",[s._v("无序性：存储数据在底层数组中根据数据的哈希值决定，不是随机分配的，按照数组索引顺序进行添加")]),s._v(" "),n("li",[s._v("不可重复性：相同元素只能添加一个。")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("HashSet元素添加过程：\n向HashSet中添加元素a\n1.调用元素a的所在类hashCode()方法，计算a的哈希值\n2.根据哈希值通过某种算法计算出在HashSet底层数组的存放位置（即为索引位置，判断数组此位置是否已有元素）\n    1）此位置没其他元素，则元素a添加成功\n\t2）此位置上其他元素b（或以链表形式存在的多个元素，则比较元素a和元素b的hash值\n\t    如果Hash值不相同，则元素a添加成功\n\t\t如果Hash值相同，调用元素a的所在类的equals()方法：\n\t\t     equals()返回true,元素a添加失败\n\t\t\t equals(),返回false,元素a，添加成功），\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br")])]),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("哈希表边存放的是哈希值。HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） \n而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的hashcode 方法来获取的, \nHashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals 方法 ，\n如果 equls 结果为 true ，HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素。\n\n哈希值相同 equals 为 false 的元素是怎么存储呢,就是在同样的哈希值下顺延（可以认为哈希值相\n同的元素放在一个哈希桶中）。也就是哈希一样的存一列。\nHashSet 通过 hashCode 值来确定元素在内存中的位置。一个 hashCode 位置上可以存放多个元\n素。\n通俗来说，就是我们可以认为有一个数组，每个数组上的位置都存储着一个链表\n向里面存数据的时候，我们先通过哈希函数计算出这个数据的HashCode，然后再根据HashCode来决定这个数据要存到的位置，\n采用头插法（JDK1.7以前）/尾插法（JDK1.8以后）\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br")])])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("TreeSet（二叉树）")]),n("p",[n("a",{attrs:{href:"https://blog.csdn.net/qq_39396275/article/details/76409089",target:"_blank",rel:"noopener noreferrer"}},[s._v("自然排序与定制排序"),n("OutboundLink")],1)]),s._v(" "),n("ul",[n("li",[s._v("可以按照添加对象的指定属性，进行排序。")]),s._v(" "),n("li",[s._v("TreeSet 继承于AbstractSet，所以它是一个Set集合，具有Set的属性和方法。")]),s._v(" "),n("li",[s._v("基于TreeMap实现的。TreeSet中的元素支持2种排序方式：自然排序 或者 根据创建TreeSet 时提供的 Comparator 进行排序。")]),s._v(" "),n("li",[s._v("TreeSet是非同步的。 它的iterator 方法返回的迭代器是fail-fast的。")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("TreeSet的构造函数：\nTreeSet() //默认构造函数。使用该构造函数，TreeSet中的元素按照自然排序进行排列。\nTreeSet(Collection<? extends E> collection) //创建的TreeSet包含collection\nTreeSet(Comparator<? super E> comparator) //指定TreeSet的比较器\nTreeSet(SortedSet<E> set) //创建的TreeSet包含set\n\nTreeSet:\n1.自然排序中，比较两个对象是否相同的标准为：compareTo()返回0.不再是equals().\n2.定制排序中，比较两个对象是否相同的标准为：compare()返回0.不再是equals().\n\n使用说明:\n1.向TreeSet中添加的数据，要求是相同类的对象。\n2.两种排序方式：自然排序（实现Comparable接口 和 定制排序（Comparator）\n\n概念：\n1.TreeSet()是使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增\n加一个对象都会进行排序，将对象插入的二叉树指定的位置。\n2. Integer 和 String 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的，自\n己定义的类必须实现 Comparable 接口，并且覆写相应的 compareTo()函数，才可以正常使\n用。\n3. 在覆写 compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序\n4. 比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整\n数、零或正整数。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br")])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("方式一：自然排序")]),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v(' public void test1(){\n        TreeSet set = new TreeSet();\n        //失败：不能添加不同类的对象\n//        set.add(123);\n//        set.add(456);\n//        set.add("AA");\n//        set.add(new User("Tom",12));\n\n            //举例一：\n//        set.add(34);\n//        set.add(-34);\n//        set.add(43);\n//        set.add(11);\n//        set.add(8);\n\n //举例二：\n        set.add(new User("Tom",12));\n        set.add(new User("Jerry",32));\n        set.add(new User("Jim",2));\n        set.add(new User("Mike",65));\n        set.add(new User("Jack",33));\n        set.add(new User("Jack",56));\n\t\t\n\t\tIterator iterator = set.iterator();\n\t    while(iterator.hasNext()){\n\t\t    System.out.println(iterator.next());\n\t\t}\n\t\t\n }\n\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br")])])])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("方式二：定制排序")]),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('public void test2(){\n        Comparator com = new Comparator() {\n            //照年龄从小到大排列\n            @Override\n            public int compare(Object o1, Object o2) {\n                if(o1 instanceof User && o2 instanceof User){\n                    User u1 = (User)o1;\n                    User u2 = (User)o2;\n                    return Integer.compare(u1.getAge(),u2.getAge());\n                }else{\n                    throw new RuntimeException("输入的数据类型不匹配");\n                }\n            }\n        };\n\n        TreeSet set = new TreeSet(com);\n        set.add(new User("Tom",12));\n        set.add(new User("Jerry",32));\n        set.add(new User("Jim",2));\n        set.add(new User("Mike",65));\n        set.add(new User("Mary",33));\n        set.add(new User("Jack",33));\n        set.add(new User("Jack",56));\n\n\n        Iterator iterator = set.iterator();\n        while(iterator.hasNext()){\n            System.out.println(iterator.next());\n        }\n    }\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br")])])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("LinkHashSet（HashSet+LinkedHashMap）")]),n("ul",[n("li",[s._v("继承与 HashSet、又基于 LinkedHashMap 来实现的,对于频繁的遍历操作，LinkedHashSet效率高于HashSet.")]),s._v(" "),n("li",[s._v("遍历其内部数据时，可以按照添加的顺序遍历，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。")]),s._v(" "),n("li",[s._v("HashSet和HashMap都不保证顺序，LinkHashSet能保证顺序，和默认插入的顺序一致。")]),s._v(" "),n("li",[s._v("特点：底层是一个哈希表（数组+链表、红黑树）+链表。多了一条链表（记录元素的存储顺序），保证元素有序。")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("对于 LinkedHashSet 而言，它继承与 HashSet、又基于 LinkedHashMap 来实现的。\nLinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法\n操作上又与 HashSet 相同，因此 LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并\n通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操\n作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可。\n\n重点：LinkedHashSet继承自HashSet，源码更少、更简单，唯一的区别是LinkedHashSet内部使用的是LinkHashMap。\n这样做的意义或者好处就是LinkedHashSet中的元素顺序是可以保证的，也就是说遍历序和插入序是一致的。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br")])])]),n("h3",{attrs:{id:"queue"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#queue"}},[s._v("#")]),s._v(" Queue")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("Queue用于模拟队列这种数据结构。队列通常是指“先进先出（FIFO）”的容器。\n队列的头部保存在队列中存放时间最长的元素，尾部保存存放时间最短的元素。\n新元素插入到队列的尾部，取出元素会返回队列头部的元素。\n通常，队列不允许随机访问队列中的元素。\n\n常用方法：\nvoid add(Object e):　　将指定元素插入到队列的尾部。\nobject element():　　获取队列头部的元素，但是不删除该元素。\nboolean offer(Object e):　　将指定的元素插入此队列的尾部。当使用容量有限的队列时，此方法通常比add(Object e)有效。　\nObject peek():　　返回队列头部的元素，但是不删除该元素。如果队列为空，则返回null。\nObject poll():　　返回队列头部的元素，并删除该元素。如果队列为空，则返回null。\nObject remove():　　获取队列头部的元素，并删除该元素。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br")])]),n("h2",{attrs:{id:"map"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[s._v("#")]),s._v(" Map")]),s._v(" "),n("ul",[n("li",[s._v("是映射表最基本的接口")]),s._v(" "),n("li",[s._v("常用方法")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("* 添加：put(Object key,Object value)\n* 删除：remove(Object key)\n* 修改：put(Object key,Object value)\n* 查询：get(Object key)\n* 长度：size()\n* 遍历：keySet() / values() / entrySet()\n\n>Map中的key:无序的、不可重复的，使用Set存储所的key  ---\x3e key所在的类要重写equals()和hashCode() （以HashMap为例)\n>Map中的value:无序的、可重复的，使用Collection存储所的value ---\x3evalue所在的类要重写equals()\n> 一个键值对：key-value构成了一个Entry对象。\n>Map中的entry:无序的、不可重复的，使用Set存储所的entry\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br")])]),n("p",[n("img",{attrs:{src:"https://gitee.com/li-wen-kai/picgo/raw/master/img/image-20210706171239539.png",alt:""}}),s._v(" "),n("img",{attrs:{src:"https://gitee.com/li-wen-kai/picgo/raw/master/img/d6b65eb6bb566e83ac01b366cb8a742c.png",alt:""}})]),s._v(" "),n("h3",{attrs:{id:"hashmap"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#hashmap"}},[s._v("#")]),s._v(" HashMap")]),s._v(" "),n("ul",[n("li",[s._v("作为Map的主要实现类；线程不安全的，效率高；存储null的key和value")]),s._v(" "),n("li",[s._v("HashMap的底层：数组+链表  （jdk7及之前)\n"),n("img",{attrs:{src:"https://gitee.com/li-wen-kai/picgo/raw/master/img/2021-07-06_172025.png",alt:"JDK1.7之前的HashMap原理图解"}})])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("大方向上，HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。\n上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。\n\n实现原理：\n*      在实例化以后，底层创建了长度是16的一维数组Entry[] table。\n*      ...可能已经执行过多次put...\n*      map.put(key1,value1):\n*      首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。\n*      如果此位置上的数据为空，此时的key1-value1添加成功。 ----情况1\n*      如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据的哈希值：\n*              如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。----情况2\n*              如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较：\n*                      如果equals()返回false:此时key1-value1添加成功。----情况3\n*                      如果equals()返回true:使用value1替换value2。\n*\n*      补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。\n*\n*     在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原的数据复制过来。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br")])]),n("ul",[n("li",[s._v("数组+链表+红黑树 （jdk 8)\n"),n("img",{attrs:{src:"https://gitee.com/li-wen-kai/picgo/raw/8f24847756dcd61ac0529a7a8220a6aae5d18778/img/2021-07-06_172250.png",alt:""}})])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由数组+链表+红黑树组成。\n根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，\n但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。\n为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，\n在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。\n\n\n实现原理：\n1. new HashMap():底层没创建一个长度为16的数组\n2. jdk 8底层的数组是：Node[],而非Entry[]\n3. 首次调用put()方法时，底层创建长度为16的数组\n4. jdk7底层结构只：数组+链表。jdk8中底层结构：数组+链表+红黑树。\n4.1 形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）\n4.2 当数组的某一个索引位置上的元素以链表形式存在的数据个数 > 8 且当前数组的长度 > 64时，此时此索引位置上的所数据改为使用红黑树存储。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br")])]),n("h4",{attrs:{id:"linkhashmap的底层实现原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#linkhashmap的底层实现原理"}},[s._v("#")]),s._v(" LinkHashMap的底层实现原理")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("LinkedHashMap底层使用的结构与HashMap相同，因为LinkedHashMap继承于HashMap.\n区别就在于：LinkedHashMap内部提供了Entry，替换HashMap中的Node.\n\nLinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历\nLinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])]),n("h3",{attrs:{id:"hashtable"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#hashtable"}},[s._v("#")]),s._v(" Hashtable")]),s._v(" "),n("ul",[n("li",[s._v("线程安全的，效率低；不能存储null的key和value4")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("Hashtable 不建议在新代码中使用，不需要线程安全\n的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br")])]),n("h4",{attrs:{id:"properties"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#properties"}},[s._v("#")]),s._v(" Properties")]),s._v(" "),n("ul",[n("li",[s._v("常用来处理配置文件。key和value都是String类型")])]),s._v(" "),n("h3",{attrs:{id:"treemap"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#treemap"}},[s._v("#")]),s._v(" TreeMap")]),s._v(" "),n("ul",[n("li",[s._v("保证照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序")]),s._v(" "),n("li",[s._v("底层使用红黑树")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，\n也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。\n如果使用排序的映射，建议使用 TreeMap。\n在使用 TreeMap 时，key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的\nComparator，否则会在运行时抛出 java.lang.ClassCastException 类型的异常。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])]),n("h3",{attrs:{id:""}},[n("a",{staticClass:"header-anchor",attrs:{href:"#"}},[s._v("#")])]),s._v(" "),n("h2",{attrs:{id:"collections工具类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#collections工具类"}},[s._v("#")]),s._v(" Collections工具类")]),s._v(" "),n("p",[s._v("1.作用：操作Collection和Map的工具类\n2.常用方法：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("reverse(List)：反转 List 中元素的顺序\nshuffle(List)：对 List 集合元素进行随机排序\nsort(List)：根据元素的自然顺序对指定 List 集合元素升序排序\nsort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序\nswap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换\nObject max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素\nObject max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素\nObject min(Collection)\nObject min(Collection，Comparator)\nint frequency(Collection，Object)：返回指定集合中指定元素的出现次数\nvoid copy(List dest,List src)：将src中的内容复制到dest中\nboolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所旧值\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br")])]),n("ul",[n("li",[s._v("说明：ArrayList和HashMap都是线程不安全的，如果程序要求线程安全，我们可以将ArrayList、HashMap转换为线程的。")]),s._v(" "),n("li",[s._v("使用synchronizedList(List list） 和 synchronizedMap(Map map）")])]),s._v(" "),n("h2",{attrs:{id:"集合面试题："}},[n("a",{staticClass:"header-anchor",attrs:{href:"#集合面试题："}},[s._v("#")]),s._v(" 集合面试题：")]),s._v(" "),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("常见的集合有哪些?")]),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("集合分为两大类：Collection和Map\nCollection接口的子接口包括：Set接口和List接口\nMap接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等\nSet接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等\nList接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("常见集合底层实现")]),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("List：\n   1）ArrayList底层：数组\n   2）LinkList底层：双向链表\nSet：\n   1）HashSet底层是HashMap，数组+链表+红黑树\n   2）LinkedHashSet底层是LinkedHashMap。\n   3）TreeSet底层是TreeMap。\nMap：\n   1）HashMap底层与HashTable原理相同，Java8版本以后如果同一位置哈希冲突大于8则链表变成红黑树。\n   2）HashTable底层：链地址法组成的哈希表（即数组+单项链表组成）。\n   3）LinkedHashMap底层修改自HashMap，包含一个维护插入顺序的双向链表。\n   4）TreeMap底层是红黑树。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br")])])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("Collection与Collections有什么区别？")]),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("Collection是一个接口，包含了一些集合的基本操作，继承这个接口主要有List和Set以及Queue\nCollections是一个工具类,提供了一系列静态方法，对各种集合实现排序、搜索、线程安全化等的操作\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br")])])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("List、Set、Map之间的区别？")]),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("List:存储的元素是有序的、可重复的\nSet:存储的元素是无序的（根据哈希值存数据）、不可重复的\nMap:使用键值对（key-value）进行存储数据,一个key-value构成了一个Entry对象。\n采用set进行存储key，\n采用collection存储value,\n采用set存储entry\t\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br")])])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("HashMap与HashTable有什么区别？")]),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("1.底层： \nJDK1.8以前的，相同，都是采用数组+链表，数组是主体，链表则是主要为了解决哈希冲突而存在的\nJDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。\nHashtable 没有这样的机制。\n\n2.初始容量大小和每次扩容大小的不同 \n ① 创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。\n ② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小\n3.对 Null key 和 Null value 的支持\nHashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；HashTable 不允许有 null 键和 null 值，否则会抛出 NullPointerException。\n\n4.线程是否安全\nHashMap是非线程安全，Hashtable是线程安全的，因为Hashtable内部的方法基本都被synchronized修饰（若是保证线程安全就使用concurrentHashMap）\n\n5.效率\n因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；\n\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br")])])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("HashMap和TreeMap的区别？")]),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("TreeMap<K,V>的Key值是要求实现java.lang.Comparable，所以迭代的时候TreeMap默认是按照Key值升序排序的；TreeMap的实现是基于红黑树结构。适用于按自然顺序或自定义顺序遍历键（key）。\nHashMap<K,V>的Key值实现散列hashCode()，分布是散列的、均匀的，不支持排序；数据结构主要是桶(数组)，链表或红黑树。适用于在Map中插入、删除和定位元素。\n\nHashMap： 基于哈希表实现。使用HashMap要求添加的键类明确定义了hashCode()和equals()[可以重写hashCaode()和equals()]，为了优化HashMap空间的使用，您可以调优初始容量和负载因子。\nTreeMap： 基于红黑树实现。TreeMap没有调优选项，因为该树总处于平衡状态。\n\n如果你需要得到一个有序的结果时就应该使用TreeMap（因为HashMap中元素的排列顺序是不固定的）。除此之外，由于HashMap有更好的性能，所以大多不需要排序的时候我们会使用HashMap。\n\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br")])])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("说一下HashMap的实现原理")]),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。\n当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。”\n这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Entry。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])]),n("ul",[n("li",[s._v("HashCode相同会发生什么？")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("Hashcode相同，并不能说明这两个对象相等，\nHashcode相同，只能说明这两个对象位于这个数组的同一个位置，这一个位置又是采用链表存储对象，这两个对象都在这个链表中\n\n因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。\n因为HashMap使用LinkedList存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在LinkedList中。\n(当向 HashMap 中添加 key-value 对，由其 key 的 hashCode() 返回值决定该 key-value 对（就是 Entry 对象）的存储位置。\n当两个 Entry 对象的 key 的 hashCode() 返回值相同时，将由 key 通过 eqauls() 比较值决定是采用覆盖行为（返回 true），还是产生 Entry 链（返回 false）。)\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br")])]),n("ul",[n("li",[s._v("两个键的hashcode相同，你如何获取值对象？")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后获取值对象。\n如果有两个值对象储存在同一个bucket，将会遍历LinkedList直到找到值对象。\n找到bucket位置之后，会调用keys.equals()方法去找到LinkedList中正确的节点，最终找到要找的值对象。\n(当程序通过 key 取出对应 value 时，系统只要先计算出该 key 的 hashCode() 返回值，在根据该 hashCode 返回值找出该 key 在 table 数组中的索引，然后取出该索引处的 Entry，最后返回该 key 对应的 value 即可。)\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br")])]),n("ul",[n("li",[s._v("如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。\n这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br")])])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("说一下HashSet的实现原理？")]),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("实现了Set接口，具备了Set集合的特性，不可重复、无序性\n\nSet中最重要的一个操作就是查找。而且通常我们会选择HashSet来实现，因为它专门对快速查找进行了优化。\nHashSet使用的是散列函数，那么它当中的元素也就无序可寻。当中是允许元素为null的。\n\n总结：\n（1）基于HashMap实现的，默认构造函数是构建一个初始容量为16，负载因子为0.75 的HashMap。封装了一个 HashMap 对象来存储所有的集合元素，所有放入 HashSet 中的集合元素实际上由 HashMap 的 key 来保存，而 HashMap 的 value 则存储了一个 PRESENT，它是一个静态的 Object 对象。\n（2）当我们试图把某个类的对象当成 HashMap的 key，或试图将这个类的对象放入 HashSet 中保存时，重写该类的equals(Object obj)方法和 hashCode() 方法很重要，而且这两个方法的返回值必须保持一致：当该类的两个的 hashCode() 返回值相同时，它们通过 equals() 方法比较也应该返回 true。通常来说，所有参与计算 hashCode() 返回值的关键属性，都应该用于作为 equals() 比较的标准。\n（3）HashSet的其他操作都是基于HashMap的。\n\n它是基于HashMap实现的，HashSet底层使用HashMap来保存所有元素，因此HashSet 的实现比较简单，相关HashSet的操作，基本上都是直接调用底层HashMap的相关方法来完成，\nimport java.util.AbstractSet;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.Set;\nimport javax.swing.text.html.HTMLDocument.Iterator;\n\npublic class HashSet<E>  extends AbstractSet<E>  implements Set<E>, Cloneable, java.io.Serializable  {  \nstatic final long serialVersionUID = -5024744406713321676L;  \n// 底层使用HashMap来保存HashSet中所有元素。  \nprivate transient HashMap<E,Object> map;  \n// 定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。  \nprivate static final Object PRESENT = new Object();  \n//  默认的无参构造器，构造一个空的HashSet。 \n//  实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。 \npublic HashSet() {  \nmap = new HashMap<E,Object>();  \n}  \n//  构造一个包含指定collection中的元素的新set。 \n//  实际底层使用默认的加载因子0.75和足以包含指定 \n//  collection中所有元素的初始容量来创建一个HashMap。 \n//  @param c 其中的元素将存放在此set中的collection。 \npublic HashSet(Collection<? extends E> c) {  \nmap = new HashMap<E,Object>(Math.max((int) (c.size()/.75f) + 1, 16));  \naddAll(c);  \n}  \n//  以指定的initialCapacity和loadFactor构造一个空的HashSet。 \n//  \n//  实际底层以相应的参数构造一个空的HashMap。 \n// @param initialCapacity 初始容量。 \n//  @param loadFactor 加载因子。 \n\npublic HashSet(int initialCapacity, float loadFactor) {  \nmap = new HashMap<E,Object>(initialCapacity, loadFactor);  \n}  \n\n \n//  以指定的initialCapacity构造一个空的HashSet。 \n//  \n//  实际底层以相应的参数及加载因子loadFactor为0.75构造一个空的HashMap。 \n//  @param initialCapacity 初始容量。 \n \npublic HashSet(int initialCapacity) {  \nmap = new HashMap<E,Object>(initialCapacity);  \n}  \n\n\n//  以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。 \n//  此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。 \n//  \n//  实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。 \n//  @param initialCapacity 初始容量。 \n//  @param loadFactor 加载因子。 \n//  @param dummy 标记。 \n   \nHashSet(int initialCapacity, float loadFactor, boolean dummy) {  \nmap = new LinkedHashMap<E,Object>(initialCapacity, loadFactor);  \n}  \n\n \n//  返回对此set中元素进行迭代的迭代器。返回元素的顺序并不是特定的。 \n//  \n// 底层实际调用底层HashMap的keySet来返回所有的key。 \n//  可见HashSet中的元素，只是存放在了底层HashMap的key上， \n//  value使用一个static final的Object对象标识。 \n//  @return 对此set中元素进行迭代的Iterator。 \n\n public Iterator<E> iterator() {  \n     return map.keySet().iterator();  \n\n}  \n \n// 返回此set中的元素的数量（set的容量）。 \n//  \n//  底层实际调用HashMap的size()方法返回Entry的数量，就得到该Set中元素的个数。 \n//  @return 此set中的元素的数量（set的容量）。 \n  \npublic int size() {  \nreturn map.size();  \n}  \n\n \n//  如果此set不包含任何元素，则返回true。 \n//  \n//  底层实际调用HashMap的isEmpty()判断该HashSet是否为空。 \n//  @return 如果此set不包含任何元素，则返回true。 \n \npublic boolean isEmpty() {  \nreturn map.isEmpty();  \n}  \n\n \n//  如果此set包含指定元素，则返回true。 \n//  更确切地讲，当且仅当此set包含一个满足(o==null ? e==null : o.equals(e)) \n//  的e元素时，返回true。 \n// \n//  底层实际调用HashMap的containsKey判断是否包含指定key。 \n// @param o 在此set中的存在已得到测试的元素。 \n// @return 如果此set包含指定元素，则返回true。 \n  \npublic boolean contains(Object o) {  \nreturn map.containsKey(o);  \n}  \n\n\n// 如果此set中尚未包含指定元素，则添加指定元素。 \n// 更确切地讲，如果此 set 没有包含满足(e==null ? e2==null : e.equals(e2)) \n// 的元素e2，则向此set 添加指定的元素e。 \n// 如果此set已包含该元素，则该调用不更改set并返回false。 \n// \n// 底层实际将将该元素作为key放入HashMap。 \n// 由于HashMap的put()方法添加key-value对时，当新放入HashMap的Entry中key \n//与集合中原有Entry的key相同（hashCode()返回值相等，通过equals比较也返回true）， \n//新添加的Entry的value会将覆盖原来Entry的value，但key不会有任何改变， \n//  因此如果向HashSet中添加一个已经存在的元素时，新添加的集合元素将不会被放入HashMap中， \n//  原来的元素也不会有任何改变，这也就满足了Set中元素不重复的特性。 \n//  @param e 将添加到此set中的元素。 \n//  @return 如果此set尚未包含指定元素，则返回true。 \n \npublic boolean add(E e) {  \n       return map.put(e, PRESENT)==null;  \n}  \n\n//  如果指定元素存在于此set中，则将其移除。 \n//  更确切地讲，如果此set包含一个满足(o==null ? e==null : o.equals(e))的元素e， \n//  则将其移除。如果此set已包含该元素，则返回true \n// （或者：如果此set因调用而发生更改，则返回true）。（一旦调用返回，则此set不再包含该元素）。 \n//  \n//  底层实际调用HashMap的remove方法删除指定Entry。 \n//  @param o 如果存在于此set中则需要将其移除的对象。 \n//  @return 如果set包含指定元素，则返回true。 \n \npublic boolean remove(Object o) {  \nreturn map.remove(o)==PRESENT;  \n}  \n\n \n//  从此set中移除所有元素。此调用返回后，该set将为空。 \n//  \n//  底层实际调用HashMap的clear方法清空Entry中所有元素。 \n \npublic void clear() {  \nmap.clear();  \n}  \n \n//  返回此HashSet实例的浅表副本：并没有复制这些元素本身。 \n\n//  底层实际调用HashMap的clone()方法，获取HashMap的浅表副本，并设置到HashSet中。 \n \npublic Object clone() {  \n    try {  \n        HashSet<E> newSet = (HashSet<E>) super.clone();  \n        newSet.map = (HashMap<E, Object>) map.clone();  \n        return newSet;  \n    } catch (CloneNotSupportedException e) {  \n        throw new InternalError();  \n    }  \n}  \n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br"),n("span",{staticClass:"line-number"},[s._v("41")]),n("br"),n("span",{staticClass:"line-number"},[s._v("42")]),n("br"),n("span",{staticClass:"line-number"},[s._v("43")]),n("br"),n("span",{staticClass:"line-number"},[s._v("44")]),n("br"),n("span",{staticClass:"line-number"},[s._v("45")]),n("br"),n("span",{staticClass:"line-number"},[s._v("46")]),n("br"),n("span",{staticClass:"line-number"},[s._v("47")]),n("br"),n("span",{staticClass:"line-number"},[s._v("48")]),n("br"),n("span",{staticClass:"line-number"},[s._v("49")]),n("br"),n("span",{staticClass:"line-number"},[s._v("50")]),n("br"),n("span",{staticClass:"line-number"},[s._v("51")]),n("br"),n("span",{staticClass:"line-number"},[s._v("52")]),n("br"),n("span",{staticClass:"line-number"},[s._v("53")]),n("br"),n("span",{staticClass:"line-number"},[s._v("54")]),n("br"),n("span",{staticClass:"line-number"},[s._v("55")]),n("br"),n("span",{staticClass:"line-number"},[s._v("56")]),n("br"),n("span",{staticClass:"line-number"},[s._v("57")]),n("br"),n("span",{staticClass:"line-number"},[s._v("58")]),n("br"),n("span",{staticClass:"line-number"},[s._v("59")]),n("br"),n("span",{staticClass:"line-number"},[s._v("60")]),n("br"),n("span",{staticClass:"line-number"},[s._v("61")]),n("br"),n("span",{staticClass:"line-number"},[s._v("62")]),n("br"),n("span",{staticClass:"line-number"},[s._v("63")]),n("br"),n("span",{staticClass:"line-number"},[s._v("64")]),n("br"),n("span",{staticClass:"line-number"},[s._v("65")]),n("br"),n("span",{staticClass:"line-number"},[s._v("66")]),n("br"),n("span",{staticClass:"line-number"},[s._v("67")]),n("br"),n("span",{staticClass:"line-number"},[s._v("68")]),n("br"),n("span",{staticClass:"line-number"},[s._v("69")]),n("br"),n("span",{staticClass:"line-number"},[s._v("70")]),n("br"),n("span",{staticClass:"line-number"},[s._v("71")]),n("br"),n("span",{staticClass:"line-number"},[s._v("72")]),n("br"),n("span",{staticClass:"line-number"},[s._v("73")]),n("br"),n("span",{staticClass:"line-number"},[s._v("74")]),n("br"),n("span",{staticClass:"line-number"},[s._v("75")]),n("br"),n("span",{staticClass:"line-number"},[s._v("76")]),n("br"),n("span",{staticClass:"line-number"},[s._v("77")]),n("br"),n("span",{staticClass:"line-number"},[s._v("78")]),n("br"),n("span",{staticClass:"line-number"},[s._v("79")]),n("br"),n("span",{staticClass:"line-number"},[s._v("80")]),n("br"),n("span",{staticClass:"line-number"},[s._v("81")]),n("br"),n("span",{staticClass:"line-number"},[s._v("82")]),n("br"),n("span",{staticClass:"line-number"},[s._v("83")]),n("br"),n("span",{staticClass:"line-number"},[s._v("84")]),n("br"),n("span",{staticClass:"line-number"},[s._v("85")]),n("br"),n("span",{staticClass:"line-number"},[s._v("86")]),n("br"),n("span",{staticClass:"line-number"},[s._v("87")]),n("br"),n("span",{staticClass:"line-number"},[s._v("88")]),n("br"),n("span",{staticClass:"line-number"},[s._v("89")]),n("br"),n("span",{staticClass:"line-number"},[s._v("90")]),n("br"),n("span",{staticClass:"line-number"},[s._v("91")]),n("br"),n("span",{staticClass:"line-number"},[s._v("92")]),n("br"),n("span",{staticClass:"line-number"},[s._v("93")]),n("br"),n("span",{staticClass:"line-number"},[s._v("94")]),n("br"),n("span",{staticClass:"line-number"},[s._v("95")]),n("br"),n("span",{staticClass:"line-number"},[s._v("96")]),n("br"),n("span",{staticClass:"line-number"},[s._v("97")]),n("br"),n("span",{staticClass:"line-number"},[s._v("98")]),n("br"),n("span",{staticClass:"line-number"},[s._v("99")]),n("br"),n("span",{staticClass:"line-number"},[s._v("100")]),n("br"),n("span",{staticClass:"line-number"},[s._v("101")]),n("br"),n("span",{staticClass:"line-number"},[s._v("102")]),n("br"),n("span",{staticClass:"line-number"},[s._v("103")]),n("br"),n("span",{staticClass:"line-number"},[s._v("104")]),n("br"),n("span",{staticClass:"line-number"},[s._v("105")]),n("br"),n("span",{staticClass:"line-number"},[s._v("106")]),n("br"),n("span",{staticClass:"line-number"},[s._v("107")]),n("br"),n("span",{staticClass:"line-number"},[s._v("108")]),n("br"),n("span",{staticClass:"line-number"},[s._v("109")]),n("br"),n("span",{staticClass:"line-number"},[s._v("110")]),n("br"),n("span",{staticClass:"line-number"},[s._v("111")]),n("br"),n("span",{staticClass:"line-number"},[s._v("112")]),n("br"),n("span",{staticClass:"line-number"},[s._v("113")]),n("br"),n("span",{staticClass:"line-number"},[s._v("114")]),n("br"),n("span",{staticClass:"line-number"},[s._v("115")]),n("br"),n("span",{staticClass:"line-number"},[s._v("116")]),n("br"),n("span",{staticClass:"line-number"},[s._v("117")]),n("br"),n("span",{staticClass:"line-number"},[s._v("118")]),n("br"),n("span",{staticClass:"line-number"},[s._v("119")]),n("br"),n("span",{staticClass:"line-number"},[s._v("120")]),n("br"),n("span",{staticClass:"line-number"},[s._v("121")]),n("br"),n("span",{staticClass:"line-number"},[s._v("122")]),n("br"),n("span",{staticClass:"line-number"},[s._v("123")]),n("br"),n("span",{staticClass:"line-number"},[s._v("124")]),n("br"),n("span",{staticClass:"line-number"},[s._v("125")]),n("br"),n("span",{staticClass:"line-number"},[s._v("126")]),n("br"),n("span",{staticClass:"line-number"},[s._v("127")]),n("br"),n("span",{staticClass:"line-number"},[s._v("128")]),n("br"),n("span",{staticClass:"line-number"},[s._v("129")]),n("br"),n("span",{staticClass:"line-number"},[s._v("130")]),n("br"),n("span",{staticClass:"line-number"},[s._v("131")]),n("br"),n("span",{staticClass:"line-number"},[s._v("132")]),n("br"),n("span",{staticClass:"line-number"},[s._v("133")]),n("br"),n("span",{staticClass:"line-number"},[s._v("134")]),n("br"),n("span",{staticClass:"line-number"},[s._v("135")]),n("br"),n("span",{staticClass:"line-number"},[s._v("136")]),n("br"),n("span",{staticClass:"line-number"},[s._v("137")]),n("br"),n("span",{staticClass:"line-number"},[s._v("138")]),n("br"),n("span",{staticClass:"line-number"},[s._v("139")]),n("br"),n("span",{staticClass:"line-number"},[s._v("140")]),n("br"),n("span",{staticClass:"line-number"},[s._v("141")]),n("br"),n("span",{staticClass:"line-number"},[s._v("142")]),n("br"),n("span",{staticClass:"line-number"},[s._v("143")]),n("br"),n("span",{staticClass:"line-number"},[s._v("144")]),n("br"),n("span",{staticClass:"line-number"},[s._v("145")]),n("br"),n("span",{staticClass:"line-number"},[s._v("146")]),n("br"),n("span",{staticClass:"line-number"},[s._v("147")]),n("br"),n("span",{staticClass:"line-number"},[s._v("148")]),n("br"),n("span",{staticClass:"line-number"},[s._v("149")]),n("br"),n("span",{staticClass:"line-number"},[s._v("150")]),n("br"),n("span",{staticClass:"line-number"},[s._v("151")]),n("br"),n("span",{staticClass:"line-number"},[s._v("152")]),n("br"),n("span",{staticClass:"line-number"},[s._v("153")]),n("br"),n("span",{staticClass:"line-number"},[s._v("154")]),n("br"),n("span",{staticClass:"line-number"},[s._v("155")]),n("br"),n("span",{staticClass:"line-number"},[s._v("156")]),n("br"),n("span",{staticClass:"line-number"},[s._v("157")]),n("br"),n("span",{staticClass:"line-number"},[s._v("158")]),n("br"),n("span",{staticClass:"line-number"},[s._v("159")]),n("br"),n("span",{staticClass:"line-number"},[s._v("160")]),n("br"),n("span",{staticClass:"line-number"},[s._v("161")]),n("br"),n("span",{staticClass:"line-number"},[s._v("162")]),n("br"),n("span",{staticClass:"line-number"},[s._v("163")]),n("br"),n("span",{staticClass:"line-number"},[s._v("164")]),n("br"),n("span",{staticClass:"line-number"},[s._v("165")]),n("br"),n("span",{staticClass:"line-number"},[s._v("166")]),n("br"),n("span",{staticClass:"line-number"},[s._v("167")]),n("br"),n("span",{staticClass:"line-number"},[s._v("168")]),n("br"),n("span",{staticClass:"line-number"},[s._v("169")]),n("br"),n("span",{staticClass:"line-number"},[s._v("170")]),n("br")])])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("ArrayList和LinkedList的区别是什么？")]),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("1.底层：ArrayList底层是动态数组，LinkedList底层是双向链表（JDK1.6之前为循环链表，JDK1.7取消了循环）\n2.效率：\n      ArrayList访问元素速度优于LinkedList，\n      LinkedList占用的内存空间比较大，但LinkedList在批量插入或删除数据时优于ArrayList。\n  说明：\n\tArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。\n    LinkedList 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（add(E e)、addFirst(E e)、addLast(E e)、removeFirst() 、 removeLast()），近似 O(1)，如果是要在指定位置 i 插入和删除元素的话（add(int index, E element)，remove(Object o)） 时间复杂度近似为 O(n) ，因为需要先移动到指定位置再插入\n3.线程安全：都是线程不安全的\n4.快速随机访问：LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。\n5.内存：ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br")])])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("如何实现数组和List之间的转换？")]),n("ul",[n("li",[s._v("List转换为数组：调用ArrayList的toArray方法")]),s._v(" "),n("li",[s._v("数组转换为List：调用Arrays的asList方法")])])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("ArrayList和Vector的区别有什么？")]),n("ul",[n("li",[s._v("Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。")]),s._v(" "),n("li",[s._v("ArrayList比Vector快，它因为有同步，不会过载。")]),s._v(" "),n("li",[s._v("ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。")])])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("Array和ArrayList有什么区别？")]),n("ul",[n("li",[s._v("Array可以容纳基本类型和对象，而ArrayList只能容纳对象。")]),s._v(" "),n("li",[s._v("Array是指定大小的，而ArrayList大小是固定的。")]),s._v(" "),n("li",[s._v("Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。")])])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("在 Queue 中 poll()和 remove()有什么区别？")]),n("ul",[n("li",[s._v("poll() 和 remove() 都是从队列中取出一个元素，")]),s._v(" "),n("li",[s._v("但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。")])])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("哪些集合类是线程安全的？")]),n("ul",[n("li",[s._v("vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。")]),s._v(" "),n("li",[s._v("statck：堆栈类，先进后出。")]),s._v(" "),n("li",[s._v("hashtable：就比hashmap多了个线程安全。")]),s._v(" "),n("li",[s._v("enumeration：枚举，相当于迭代器。")])])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("迭代器 Iterator 是什么？")]),n("ul",[n("li",[s._v("迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。")]),s._v(" "),n("li",[s._v("迭代器通常被称为“轻量级”对象，因为创建它的代价小。")])])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("Iterator 怎么使用？有什么特点？")]),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("Java中的Iterator功能比较简单，并且只能单向移动：\n(1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。\n(2) 使用next()获得序列中的下一个元素。\n(3) 使用hasNext()检查序列中是否还有元素。\n(4) 使用remove()将迭代器新返回的元素删除。\nIterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br")])])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("Iterator 和 ListIterator 有什么区别？")]),n("ul",[n("li",[s._v("Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。")]),s._v(" "),n("li",[s._v("Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。")]),s._v(" "),n("li",[s._v("ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。")])])]),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("怎么确保一个集合不能被修改？")]),n("ul",[n("li",[s._v("可以使用Collections. unmodifiableCollection(Collectionc) 方法来创建一个只读集合，这样任何改变集合的操作都会抛出异常。")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("用Collections的\nunmodifiableCollection（Collection c）\nunmodifiableList（List list）\nunmodifiableSet（Set set）\nunmodifiableMap（Map map）\n方法创建只读的集合。\n任何修改操作都会抛出UnsupportedOperationException\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br")])])])])}),[],!1,null,null,null);a.default=t.exports}}]);