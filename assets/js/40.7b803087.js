(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{452:function(s,e,n){"use strict";n.r(e);var i=n(2),t=Object(i.a)({},(function(){var s=this,e=s.$createElement,n=s._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h2",{attrs:{id:"cookie-和-session-的区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#cookie-和-session-的区别"}},[s._v("#")]),s._v(" Cookie 和 Session 的区别")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("Cookie 是 web 服务器发送给浏览器的一块信息，浏览器会在本地一个文件中给每个 web 服务器存储 cookie。\n以后浏览器再给特定的 web 服务器发送请求时，同时会发送所有为该服务器存储的 cookie。\nSession 是存储在 web 服务器端的一块信息。session 对象存储特定用户会话所需的属性及配置信息。\n当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。\nCookie 和 session 的不同点：\n1、无论客户端做怎样的设置，session 都能够正常工作。当客户端禁用 cookie 时将无法使用 cookie。\n2、在存储的数据量方面：session 能够存储任意的 java 对象，cookie 只能存储 String 类型的对象。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br")])]),n("h2",{attrs:{id:"session-共享怎么做的（分布式如何实现-session-共享）？"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#session-共享怎么做的（分布式如何实现-session-共享）？"}},[s._v("#")]),s._v(" session 共享怎么做的（分布式如何实现 session 共享）？")]),s._v(" "),n("ul",[n("li",[s._v("参考原文：http://blog.csdn.net/sxiaobei/article/details/57086489")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("问题描述：\n一个用户在登录成功以后会把用户信息存储在 session 当中，这时 session 所在服务器为 server1，那么用户在 session 失效之前如果再次使用 app，那么可能会被路由到 server2，这时问题来了，server 没有该用户的session，所以需要用户重新登录，这时的用户体验会非常不好，所以我们想如何实现多台 server 之间共享 session， 让用户状态得以保存。\n1 、服务器实现的 session 复制或 session 共享，这类型的共享 session 是和服务器紧密相关的，比如webSphere 或 JBOSS 在搭建集群时候可以配置实现 session 复制或 session 共享，但是这种方式有一个致命的缺点，就是不好扩 展和移植，比如我们更换服务器，那么就要修改服务器配置。\n2、利用成熟的技术做 session 复制，比如 12306 使用的 gemfire，比如常见的内存数据库如 redis 或 memorycache，这类方案虽然比较普适，但是严重依赖于第三方，这样当第三方服务器出现问题的时候，那么将是应用的灾难。\n3、将 session 维护在客户端，很容易想到就是利用 cookie，但是客户端存在风险，数据不安全，而且可以存放的数据量比较小，所以将 session 维护在客户端还要对 session 中的信息加密。\n我们实现的方案可以说是第二种方案和第三种方案的合体，可以利用 gemfire 实现 session 复制共享，\n还可以将session 维护在 redis 中实现 session 共享，同时可以将 session 维护在客户端的 cookie 中，但是前提是数据要加密。\n这三种方式可以迅速切换，而不影响应用正常执行。我们在实践中，首选 gemfire 或者 redis 作为 session 共享的载体，\n一旦 session 不稳定出现问题的时候，可以紧急切换 cookie 维护 session 作为备用，不影响应用提供服务。\n这里主要讲解 redis 和 cookie 方案，gemfire 比较复杂大家可以自行查看 gemfire 工作原理。\n利用 redis 做session 共享，首先需要与业务逻辑代码解耦，不然 session 共享将没有意义，其次支持动态切换到客户端 cookie 模式。\nredis的方案是，重写服务器中的 HttpSession和 HttpServletRequest，首先实现HttpSession接口，重写 session 的所有方法，\n将  session 以 hash 的方式存在redis中,一个 session 的 key 就是 sessionID，setAtrribute重写之后就是更新 redis 中的数据，\ngetAttribute 重写之后就是获取 redis 中的数据，等等需要将HttpSession 的接口一一 实现。\n实现了 HttpSesson，那么我们先将该 session 类叫做 MySession（当然实践中不是这么命名的），\n当 MySession 出现之后问题才开始，怎么能在不影响业务逻辑代码的情况下，\n还能让原本的 request.getSession（）获取到的是MySession，而不是服务器原生的 session。\n这里，我决定重写服务器的 HttpServletRequet，这里先称为 MyRequest，但是这可不是单纯的重写，\n我需要在原生的 request 基础上重写，于是我决定在 filter 中，实现 request 的偷梁换柱，\n 我的思路是这样的，MyRequest 的构建器，必须以 request 作为参数，\n 于是我在 filter 中将服务器原生的 request（也有可能是框架封装过的 request ），当做参数 new 出来一个 MyRequest ， \n 并且 MyRequest 也实现了HttpServletRequest 接口，其实就是对原生 request 的一个增强，\n 这里主要重写了几个 request 的方法，但是最重要的是重写了 request.getSession()，\n 写到这里大家应该都明白为什么重写这个方法了吧，当然是为了获取 MySession，\n于是这样就在filter 中，偷偷的将原生的request 换成MyRequest 了，然后再将替换过的 request 传入chan.doFilter()，\n 这样 filter 时候的代码都使用的是 MyRequest 了，同时对业务代码是透明的，\n 业务代码获取 session 的方法仍然是request.getSession（），但其实获取到的已经是 MySession 了，\n 这样对 session 的操作已经变成了对 redis 的操作。这样实现的好处有两个，\n 第一开发人员不需要对 session 共享做任何关注，session 共享对用户是透明的；\n 第二，filter 是可配置的，通过 filter 的方式可以将 session 共享做成一项可插拔的功能，没有任何侵入性。\n这个时候已经实现了一套可插拔的 session 共享的框架了，但是我们想到如果 redis 服务出了问题，这时我们该怎么办呢，\n于是我们延续 redis 的想法，想到可以将 session 维护在客户端内（加密的 cookie），\n当然实现方法还是一样的，我们重写 HttpSession 接口，实现其所有方法，\n比如 setAttribute 就是写入 cookie，getAttribute 就是读取cookie，我们可以将重写的 session 称作 MySession2，\n这时怎么让开发人员透明的获取到 MySession2 呢，实现方法还是在 filter 内偷梁换柱，在 MyRequest 加一个判断，\n读取 sessionType 配置，如果 sessionType 是 redis 的，那么 getSession 的时候获取到的是 MySession，\n如果 sessionType 是 coolie 的，那么 getSession 的时候获取到的是MySession2，以此类推，\n用同样的方法就可以获取到 MySession 3,4,5,6 等等。\n这样两种方式都有了，那么我们怎实现两种 session 共享方式的快速切换呢，刚刚我提到一个 sessionType，\n这是用来决定获取到 session 的类型的，只要变换 sessionType 就能实现两种 session 共享方式的切换，\n但是sessionType 必须对所有的服务器都是一致的，如果不一致那将会出现比较严重的问题，\n我们目前是将 sessionType 维护在环境变 量里，如果要切换 sessionType 就要重启每一台服务器，\n完成 session 共享的转换，但是当服务器太多的时候将是一 种灾难。而且重启服务意味着服务的中断，\n所以这样的方式只适合服务器规模比较小，而且用户量比较少的情况，当服务器太多的时候，务必需要一种协调技术，\n能够让服务器能够及时获取切换的通知。基于这样的原因，我们选用\tzookeeper 作为配置平台， \n每一台服务器都会订阅 zookeeper 上的配置，当我们切换sessionType 之后，所有服务 器都会订阅到修改之后的配置，\n那么切换就会立即生效，当然可能会有短暂的时间延迟， 但这是可以接受的。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br"),n("span",{staticClass:"line-number"},[s._v("41")]),n("br"),n("span",{staticClass:"line-number"},[s._v("42")]),n("br"),n("span",{staticClass:"line-number"},[s._v("43")]),n("br"),n("span",{staticClass:"line-number"},[s._v("44")]),n("br"),n("span",{staticClass:"line-number"},[s._v("45")]),n("br"),n("span",{staticClass:"line-number"},[s._v("46")]),n("br"),n("span",{staticClass:"line-number"},[s._v("47")]),n("br")])]),n("h2",{attrs:{id:"在单点登录中，如果-cookie-被禁用了怎么办？"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#在单点登录中，如果-cookie-被禁用了怎么办？"}},[s._v("#")]),s._v(" 在单点登录中，如果 cookie 被禁用了怎么办？")]),s._v(" "),n("ul",[n("li",[s._v("单点登录的原理是后端生成一个 session ID，然后设置到 cookie，后面的所有请求浏览器都会带上 cookie， 然后服务端从 cookie 里获取 session ID，再查询到用户信息。")]),s._v(" "),n("li",[s._v("所以，保持登录的关键不是 cookie，而是通过cookie 保存和传输的 session ID，其本质是能获取用户信息的数据。")]),s._v(" "),n("li",[s._v("除了 cookie，还通常使用 HTTP 请求头来传输。")]),s._v(" "),n("li",[s._v("但是这个请求头浏览器不会像 cookie 一样自动携带，需要手工处理。")])])])}),[],!1,null,null,null);e.default=t.exports}}]);