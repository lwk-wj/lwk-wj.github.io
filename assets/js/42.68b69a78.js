(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{455:function(e,t,a){"use strict";a.r(t);var s=a(2),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"原生jdbc操作数据库流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原生jdbc操作数据库流程"}},[e._v("#")]),e._v(" 原生jdbc操作数据库流程")]),e._v(" "),a("div",{staticClass:"language-html line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-html"}},[a("code",[e._v("第一步：Class.forName()加载数据库连接驱动；\n第二步：DriverManager.getConnection()获取数据连接对象;\n第三步：根据 SQL 获取 sql 会话对象，有 2 种方式 Statement、PreparedStatement ; 第四步：执行 SQL 处理结果集，执行 SQL 前如果有参数值就设置参数值 setXXX();\n第五步：关闭结果集、关闭会话、关闭连接。 详细代码请看（封装）： \nhttp://blog.csdn.net/qq_29542611/article/details/52426006\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br")])]),a("h2",{attrs:{id:"为什么要使用preparedstatement？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么要使用preparedstatement？"}},[e._v("#")]),e._v(" 为什么要使用PreparedStatement？")]),e._v(" "),a("ul",[a("li",[e._v("1.PreparedStatement 接口继承 Statement， PreparedStatement 实例包含已编译的 SQL 语句，所以其执行速度要快于 Statement 对象。")]),e._v(" "),a("li",[e._v("2.作为Statement的子类，PreparedStatement继承了Statement的所有功能 。三种方法execute、executeQuery和executeUpdate已被更改以使之不再需要参数")]),e._v(" "),a("li",[e._v("3.在 JDBC 应用中,在任何时候都不要使用 Statement")])]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("不要使用 Statement的原因如下：\n1.代码的可读性和可维护性.Statement 需要不断地拼接，而 PreparedStatement 不会。\n2.PreparedStatement 尽最大可能提高性能.DB 有缓存机制，相同的预编译语句再次被调用不会再次需要编译。\n3.最重要的一点是极大地提高了安全性.Statement 容易被 SQL 注入，而 PreparedStatementc 传入的内容不会和 sql 语句发生任何匹配关系。\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])]),a("h2",{attrs:{id:"关系数据库中连接池的机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关系数据库中连接池的机制"}},[e._v("#")]),e._v(" 关系数据库中连接池的机制")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("前提：为数据库连接建立一个缓冲池。\n1：从连接池获取或创建可用连接\n2：使用完毕之后，把连接返回给连接池\n3：在系统关闭前，断开所有连接并释放连接占用的系统资源\n4：能够处理无效连接，限制连接池中的连接总数不低于或者不超过某个限定值。 \n其中有几个概念需要大家理解：\n最小连接数是连接池一直保持的数据连接。如果应用程序对数据库连接的使用量不大，将会有大量的数据库连接资源被浪费掉。\n最大连接数是连接池能申请的最大连接数。如果数据连接请求超过此数，后面的数据连接请求将被加入到等待队列中，这会影响之后的数据库操作。\n如果最小连接数与最大连接数相差太大，那么，最先的连接请求将会获利，之后超过最小连接数量的连接请求等价于建立一个新的数据库连接。\n不过，这些大于最小连接数的数据库连接在使用完不会马上被释放，它将被放到连接池中等待重复使用或是空闲超时后被释放。\n上面的解释，可以这样理解：数据库池连接数量一直保持一个不少于最小连接数的数量，当数量不够时，数据库会创建一些连接，直到一个最大连接数，之后连接数据库就会等待。\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br")])])])}),[],!1,null,null,null);t.default=n.exports}}]);