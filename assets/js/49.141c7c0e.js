(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{462:function(t,e,s){"use strict";s.r(e);var a=s(2),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"springmvc框架"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#springmvc框架"}},[t._v("#")]),t._v(" SpringMVC框架")]),t._v(" "),s("h2",{attrs:{id:"流程原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#流程原理"}},[t._v("#")]),t._v(" 流程原理")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("a.\t用户向服务器发送请求，请求被 springMVC 前端控制器 DispatchServlet 捕获；\nb.\tDispatcherServle 对请求 URL 进行解析，得到请求资源标识符（URL），然后根据该 URL 调用 HandlerMapping将请求映射到处理器 HandlerExcutionChain；\nc.\tDispatchServlet 根据获得 Handler 选择一个合适的 HandlerAdapter 适配器处理；\nd.\tHandler 对数据处理完成以后将返回一个 ModelAndView（）对象给 DisPatchServlet;\ne.\tHandler 返回的 ModelAndView() 只是一个逻辑视图并不是一个正式的视图， DispatcherSevlet 通过ViewResolver 试图解析器将逻辑视图转化为真正的视图 View;\nh. DispatcherServle 通过 model 解析出 ModelAndView()中的参数进行解析最终展现出完整的 view 并返回给客户端;\n\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br")])]),s("details",{staticClass:"custom-block details"},[s("summary",[t._v("常用注解")]),s("p",[t._v("@requestMapping 用于请求 url 映射。\n@RequestBody 注解实现接收 http 请求的 json 数据，将 json 数据转换为 java 对象。\n@ResponseBody 注解实现将 controller 方法返回对象转化为 json 响应给客户。")])]),s("details",{staticClass:"custom-block details"},[s("summary",[t._v("如何开启注解处理器和适配器？")]),s("p",[t._v("我们在项目中一般会在 springmvc.xml 中通过开启 "),s("a",{attrs:{href:"mvc:annotation-driven"}},[t._v("mvc:annotation-driven")]),t._v("来实现注解处理器和适配器的开启。")])]),s("details",{staticClass:"custom-block details"},[s("summary",[t._v("如何解决 get 和 post 乱码问题？")]),s("ul",[s("li",[t._v("解决post请求乱码:我们可以在 web.xml 里边配置一个 CharacterEncodingFilter 过滤器,设置为utf-8. 解决 get 请求的乱码:")]),t._v(" "),s("li",[t._v("有两种方法。对于 get 请求中文参数出现乱码解决方法有两个:\n1)修改 tomcat 配置文件添加编码与工程编码一致。\n2)对\t参数进行重新编码String userName =\tNew String(Request.getParameter(“userName”).getBytes(“ISO8859-1”), “utf-8”);")])])])])}),[],!1,null,null,null);e.default=n.exports}}]);